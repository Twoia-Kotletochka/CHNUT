;***** Програма до лабораторної роботи №2 (стенд EV8031/AVR) *****
;*** Працюємо зі статичним семисегментним індикатором ***
;*** Відображаємо на статичному індикаторі інформацію за наступним алгоритмом
;(Стану ХХХХ відповідає повне гасіння індикатора) 0000, ХХХХ, 1111, ХХХХ, 2222, ХХХХ, ... EEEE, ХХХХ, FFFF, ХХХХ.
;Затримка на відображення одного стану дорівнює 2 с

;Підключення файлу, що містить опис регістрів і адрес для ATmega8515
.include "m8515def.inc"

;*** Призначення символічних імен регістрів ***

.def temp = r16	;регістр тимчасового зберігання
.def dig = r17	;регістр зберігання виведених на правий індикатор чисел (в hex-форматі)
.def counter = r18		;лічильник циклу в підпрограмі генерації затримки
.def counter1 = r20		;лічильник кількості пройдених станів алгоритму
.def const = r19		;регістр, який зберігає константу, що додається до маски
.def long_delay_low = r24	;молодший байт лічильника довгої затримки
.def long_delay_high = r25	;старший байт лічильника довгої затримки
.def dig0 = r21 ;регістр зберігання виведених на левий індикатор чисел 00
.def counter2 = r23 ;лічильник кількості пройдених станів алгоритму

;*** Призначення констант ***

;адреса пари лівих знакомісць статичного семисегментного індикатора
.EQU stat_7seg_left = 0xA000
;адреса пари правих знакомісць статичного семисегментного індикатора
.EQU stat_7seg_right = 0xB000
;адреса регістра керування запаленням/гасінням точок/знакомісць статичного семисегментний індикатора
.EQU stat_7seg_control = 0xA004

;***** Початок програми *****

.CSEG		;визначаємо початок сегмента коду
.ORG 0x0000	;визначаємо адресу початку сегмента коду в пам'яті програм

; *** Вектор переривань контролера ***

	rjmp Init; вектор переривання по скиданню
	reti; rjmp EXT_INT0; IRQ0 Handler
	reti; rjmp EXT_INT1; IRQ1 Handler
	reti; rjmp TIM1_CAPT; Timer1 Capture Handler
	reti; rjmp TIM1_COMPA; Timer1 Compare A Handler
	reti; rjmp TIM1_COMPB; Timer1 Compare B Handler
	reti; rjmp TIM1_OVF; Timer1 Overflow Handler
	reti; rjmp TIM0_OVF; Timer0 Overflow Handler
	reti; rjmp SPI_STC; SPI Transfer Complete Handler
	reti; rjmp USART_RXC; USART RX Complete Handler
	reti; rjmp USART_UDRE; UDR0 Empty Handler
	reti; rjmp USART_TXC; USART TX Complete Handler
	reti; rjmp ANA_COMP; Analog Comparator Handler
	reti; rjmp EXT_INT2; IRQ2 Handler
	reti; rjmp TIM0_COMP; Timer0 Compare Handler
	reti; rjmp EE_RDY; EEPROM Ready Handler
	reti; rjmp SPM_RDY; Store Program memory Ready

;*** Початкова ініціалізація контролера ***

Init:

	ldi temp, low (RAMEND)	;ініціалізація вказівника стеку SP
	out SPL, temp
	ldi temp, high (RAMEND)
	out SPH, temp	;встановлення SP на адресу останньої комірки Internal SRAM
	sbi ACSR, 7		;відключення живлення аналогового компаратора

;дозволяємо роботу із зовнішньою пам'яттю (звернення до системного контролеру)
	ldi temp, 0b10000000
	out MCUCR, temp

;Працюємо зі статичним семисегментним індикатором

;Встановлюємо вказівник X на адресу лівої пари знакомісць статичного індикатора
	ldi XL, low (stat_7seg_left)
	ldi XH, high (stat_7seg_left)

;Встановлюємо вказівник Y на адресу правої пари знакомісць статичного індикатора
	ldi YL, low (stat_7seg_right)
	ldi YH, high (stat_7seg_right)

;Встановлюємо вказівник Z на адресу регістра керування статичним індикатором
	ldi ZL, low (stat_7seg_control)
	ldi ZH, high (stat_7seg_control)

;*** Переходимо в нескінченний цикл ***

Infinite_loop:	;нескінченний цикл
	ldi dig, 0xFF	;заносимо початкове значення, яке виводиться на правий індикатор
	ldi dig0, 0x00 ; заносимо значення для лівого індикатора
	ldi const, 0x01	;заносимо число 0х11, на яке буде зменшуватися початкове
	ldi counter1, 0xFF	;ініціалізуємо значення лічильника алгоритму (FF - 255)
	
Loop1:
	st X, dig0	;видаємо маску на ліву пару знакомісць індикатора
	st Y, dig	;видаємо маску на праву пару знакомісць індикатора
	ldi temp, 0x03	;вимикаємо всі точки і запалюємо всі знакомісця
	st Z, temp		;записуємо цю маску в регістр керування індикатором
	rcall long_delay	;викликаємо затримку приблизно на 1.5 с
	sub dig, const	; віднімаємо від початкового значення маски число 01h
	dec counter1	;зменшуємо значення лічильника кількості ітерацій на 1
	
	breq loop	;перехід здійниться, якщо лічильник дорівнює 0
	rjmp loop1 ;стрибаємо на виконання наступної ітерації алгоритму

Loop:
	ldi counter2, 0xFF 	;ініціалізуємо значення лічильника алгоритму
Loop2:
	st X, dig0	;видаємо маску на ліву пару знакомісць індикатора
	st Y, dig	;видаємо маску на праву пару знакомісць індикатора
	ldi temp, 0x03	;вимикаємо всі точки і запалюємо всі знакомісця
	st Z, temp		;записуємо цю маску в регістр керування індикатором
	rcall long_delay	;викликаємо затримку приблизно на 1.5 с
	add dig, const	;додаємо до початкового значення маски число 01h
	dec counter2	;зменшуємо значення лічильника кількості ітерацій на 1
	breq Infinite_loop	;перехід здійниться, якщо лічильник дорівнює 0
	rjmp Loop2			;стрибаємо на виконання наступної ітерації алгоритму

;*** Підпрограма довгої затримки ***

long_delay:
;* Якщо в регістрову пару завантажити число 18432 (4800h), то затримка буде близько 2 секунд

;* Приблизна формула розрахунку коефіцієнта при кварці у 7.3728 МГц така:
;* 800 x коефіцієнт затримки / (7.3728 * 1 000 000) = необхідний час в [с]

	ldi long_delay_low, 0x00;завантаження в регістрову пару коефіцієнта затримки
	ldi long_delay_high, 0x36	;(3600h), це буде затримка на 1.5 с

long_loop:	;тіло циклу займає 796 + 2 + 2 = 800 тактів
	rcall short_delay		;коротка затримка
	sbiw long_delay_high: long_delay_low, 0b00000001	;віднімання з пари числа 1 (декремент довгого лічильника)
	brne long_loop	;якщо не 0, повторити цикл
	ret			;повернення в основну програму

;*** Підпрограма короткої затримки (потрібна для генерації довгих затримок) ***
short_delay:	;вся підпрограма займає рівно 796 тактів разом з rcall і ret

	nop
	ldi counter, 0xC5	;лічильник циклу
short_loop:
	nop
	dec counter
	brne short_loop	;команда розгалуження по прапорцю нуля (зациклення)
	ret			;повернення в основну програму
.EXIT				;кінець програми
