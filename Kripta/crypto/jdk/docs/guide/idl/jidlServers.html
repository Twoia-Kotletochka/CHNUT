<HTML>
<HEAD>
   <TITLE>Java IDL: Developing Servers</TITLE>
<!-- Changed by: vlc, 6/27/97 -->
   <X-SAS-WINDOW TOP=42 BOTTOM=477 LEFT=4 RIGHT=534>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<H1 ALIGN=CENTER>Developing Servers</H1>
<HR>

<P>This section introduces Java&nbsp;IDL support for servers of transient
CORBA objects. The <A HREF="GShome.html">Hello World example</A>
includes a transient object server.

<P>Topics in this section include:
<UL>
<LI><A href="#transient&persistent">Transient and Persistent Objects</A>
<LI><A href="#servants">Servants and Servant Base Classes</A>
<LI><A href="#usingservants">Using Servant Objects</A>
<LI><A href="#DSI">Dynamic Skeleton Interface</A>
<LI><A href="#ties">Delegation-based Skeletons (Ties)</A>
</UL>


<!--***************TRANSIENT AND PERSISTENT OBJECTS*************-->

<A name="transient&persistent">
<H2>Transient and Persistent Objects</H2></A>

<P>A transient CORBA object has the same lifetime as the execution of
the server process that creates it. When a server terminates, its
transient objects disappear with it and any object references held by
the client become invalid. Transient objects are often used
to effect asynchronous, or callback communication between applications and
objects. For example, suppose a timing service notifies a client application 
when an interval expires; it could do so as follows:</P>

<UL>
   <LI>The timing service defines an interface for a notifier object
   that includes an <TT>interval_expired()</TT> operation.<P>
   
   <LI>The timing service requires that a client pass a notifier
   object to the timing service's <TT>set_interval()</TT> operation.<P>
   
   <LI>The timing service client application implements a transient object that
   implements the notifier interface.<P>
   
   <LI>The client application creates and passes a notifier object
   to the timing service.<P>
   
   <LI>When the interval expires, the timing service invokes the
   notifier object's <TT>interval_expired()</TT> operation.<P>
</UL>

<P>The arrangement, in other words, is much like a callback in
procedural programming.</P>

<P>By contrast, a persistent object lives until it is explicitly
destroyed. If a client has a reference to a persistent CORBA object,
that reference can be used even if the object's server is not
running -- an ORB daemon will start the server when the ORB receives an
invocation on the object.</P>

<P>At present, Java&nbsp;IDL supports only transient object servers.
Although persistent object servers can't yet be written using Java&nbsp;IDL, 
Java applets and applications can be clients of persistent CORBA objects
whose servers are written in other languages, such as C++, or in other
Java ORB implementations.</P>


<!--***************SERVANTS AND BASE CLASSES***************-->

<A name="servants">
<H2>Servants and Servant Base Classes</H2></A>

<P>To implement a server for transient CORBA objects of some type,
you write a Java class called a <I>servant</I>, which inherits from a
class called the <I>servant base</I>; servant base classes are
optionally generated by the idltojava compiler. An
instance of a transient CORBA object is implemented by an instance of
its servant class.</P>

<P>The servant base class is the CORBA type-specific interface
between the ORB and the servant code (skeleton) for the type. It unmarshals
incoming parameters, invokes servant methods, marshals results, and
directs the ORB to return results to the client ORB.</P>

<P>A servant class extends its servant base with a method for each
operation in the IDL interface definition it implements. (OMG IDL
attributes require one method if they are read only, two if they are
writable.) For example, consider the following OMG IDL:</P>

<PRE>module Notifiers {
   interface SimpleNotifier {
      void alert (in long alert_id);
   };
};
</PRE>

<P>A servant for this type might look as follows:</P>

<PRE>import Notifiers.*
&nbsp;
class SimpleNotifierServant extends _SimpleNotifierImplBase {
   
   void alert (int alert_id) {
      // do something about the alert ...
      return;
   }
}
</PRE>

<P>The server class could create an instance of
<TT>SimpleNotifierServant</TT> as follows:</P>

<PRE>  SimpleNotifierServant SimpleNotifier = new SimpleNotifierServant(); 
  orb.connect(SimpleNotifier); 
</PRE>

<P>The <TT>orb.connect()</TT> call registers the object and the
servant with the ORB so that the ORB will invoke the servant when the
CORBA object is invoked. When the server terminates, the ORB destroys
its records for that server's CORBA objects so that subsequent
invocations will result in an <TT>OBJECT_NOT_EXIST</TT> exception. A server
can alternatively annul its CORBA objects before terminating by
calling <TT>orb.disconnect()</TT>. </P>


<!--****************USING SERVANTS*****************-->

<A name="usingservants">
<H2>Using Servant Objects</H2></A>

<P>A transient CORBA object is implemented by a Java servant object.
A servant object can be passed as a parameter to any method that
needs a CORBA object reference of that type. For example, suppose a
Java program wants to learn when the price of Sun Microsystems stock
rises above 150. The program has obtained a reference to a CORBA
stock-watcher object that provides the following operation (shown in
IDL and Java):</P>

<PRE>// IDL
interface StockWatcher {
void set_threshold(
   in string stock_symbol,
   in short stock_price,
   in Notifiers::SimpleNotifier notifier_obj);
};
&nbsp;
// Java
void set_threshold(
   String stock_symbol, 
   short stock_price, 
   Notifiers.SimpleNotifier notifier_obj)
  { // set the threshold ... 
  }
&nbsp;</PRE>

<P>To call <CODE>set_threshold()</CODE>, you need to create a
<CODE>SimpleNotifier</CODE> CORBA object. Assuming you've imported a
servant class called <CODE>SimpleNotifierImpl</CODE>, here's how to
do it:</P>

<PRE>SimpleNotifier SUNWnotifier = new SimpleNotifierImpl(); 
int stockPrice = 150;
orb.connect(SUNWnotifier);
StockWatcher aStockWatcher = // code to get a stock-watcher reference; 
&nbsp;
aStockWatcher.set_threshold ("SUNW", stockPrice, SUNWnotifier);
&nbsp;</PRE>


<A name="DSI">
<H3>Dynamic Skeleton Interface</H3></A>

<P>DSI allows servers to serve a servant object without prior (compile time) knowledge 
of the object's interface.  Instead of using skeleton code compiled from the IDL 
interface definition, the server constructs an operation invocation dynamically.
 
<H4>Why Use DSI?</H4>

<P>Use DSI for servers that cannot have compile-time knowledge of the 
implementation interface. For example, you might need a bridging application to 
allow CORBA clients to invoke services residing in a COM environment while 
allowing COM clients the same access to services residing in the CORBA realm. 
Each environment has its own, very different way of building requests and 
responses.

<P>This bridging application would use DSI to convert a CORBA client request to a format understood by a COM server. And it 
would use <A HREF="jidlClients.html#DynamicInvocation">DII</A> to convert a COM client request to a format understood by a CORBA 
server. The application programmer writes all the code to perform this work.

<P>Contrast this with a typical static object invocation. The server has access 
to the compiled skeletons for the interfaces being invoked upon. These skeletons 
are generated by compiling the IDL interface definitions with the idltojava 
compiler. When the ORB receives a request, it uses the skeleton code to build 
the operation arguments on the server side and to send back any result. 

 
<H4>Steps to Using DSI</H4>

<P>To use DSI, implement and register a dynamic servant by doing the following:

<OL>
<LI>Declare your class to extend 
<CODE>org.omg.CORBA.DynamicImplementation</CODE>.<P>

<LI>Implement the <CODE>invoke()</CODE> method.
<BR>Write the <CODE>invoke()</CODE> method code to work with a 
<CODE>ServerRequest</CODE> object to:

<OL TYPE=a>
<LI>Extract the operation name via a call on <CODE>op_name()</CODE>.

<LI>Build an <CODE>NVList</CODE> of the operation parameters (this requires type 
information on the parameters, possibly from an interface repository).

<LI>Extract the parameter values via a call on <CODE>params()</CODE>, passing 
the <CODE>NVList</CODE>.

<LI>Perform the operation, assigning new values to out and inout parameters in 
the <CODE>NVList</CODE> as appropriate.

<LI>Call either <CODE>result()</CODE> or <CODE>except()</CODE>, as appropriate.
</OL>

<B>Note:</B> The calls to <CODE>params()</CODE> and then to <CODE>result()</CODE> or 
<CODE>except()</CODE> must be made in the proper order. You must call 
<CODE>params()</CODE> before calling either of the other two methods, and you
must call only one of <CODE>result()</CODE> or <CODE>except()</CODE> once
only. Failure to observe any of these limitations results in a 
<CODE>BAD_INV_ORDER</CODE> exception.<P>

<LI>Implement the <CODE>_ids()</CODE> method.
<BR>This method is inherited from 
<CODE>org.omg.CORBA.portable.ObjectImpl</CODE>, the superclass of 
<CODE>DynamicImplementation</CODE>. It returns the repository IDs of the 
interfaces implemented by this dynamic server.<P>

<LI>Create an instance of the DSI object and register it with the ORB via a call 
to <CODE>org.omg.CORBA.ORB.connect()</CODE>.
</OL>

   
<H4>DSI Example</H4>

<P>Here is DSI.idl, which defines a  very simple interface to be implemented dynamically.

<PRE>
//IDL
module JavaIDL {
  interface DSIExample {
    void print_args(in string arg1, in short arg2);
  };
};
</PRE>

<P>Here is the corresponding Java code, from the file DSIServer.java. This portion shows the implementation of <CODE>invoke()</CODE> and the dynamic handling of the <CODE>print_args()</CODE> operation defined in DSI.idl.

<PRE>
//Java
import java.util.*;
import org.omg.CORBA.*;

// Dynamic servant class implementation
class DSIExampleServantImpl extends DynamicImplementation {

  // Store the repository ID for the interface implemented 
  static String[] myIds = {"IDL:JavaIDL/DSIExample:1.0"};

  // Create a reference to the ORB
  ORB orb;
  DSIExampleServantImpl(ORB orb) {
    this.orb = orb;
  }

  // Implementation of invoke() for handling dynamic requests
  public void invoke(ServerRequest request) {
    try {
      System.out.println("DSI: invoke called, op = "+ request.op_name());
    
      // Create an NVList to hold the parameters
      NVList nvlist = orb.create_list(0);

      // Check if the request is for the operation
      // "print_args"
      if (request.op_name().equals("print_args") == true) {

        // Add first argument to NVList
        Any any1 = orb.create_any();
        any1.insert_string("");
        nvlist.add_value("arg1", any1, ARG_IN.value);

        // Add second argument to NVList
        Any any2 = orb.create_any();
        any2.insert_short((short)0);
        nvlist.add_value("arg2", any2, ARG_IN.value);    

        //Pass the NVList to the request, to get values
        request.params(nvlist);

        // Extract values and print arguments
        System.err.println("Argument 1: In value: " 
			    + nvlist.item(0).value().extract_string());
        System.err.println("Argument 2: In value: "
			    + nvlist.item(1).value().extract_short());
        TypeCode result_tc = orb.get_primitive_tc(TCKind.tk_void);
        Any result_any = orb.create_any(); 
        result_any.type(result_tc);

	// Set the void result
        request.result(result_any);
      }
    } 
    catch ( Exception ex ) {
      ex.printStackTrace();
      System.out.println("DSIExample: Exception thrown: " + ex);
    }
  }

  // Implement the _ids() method to return repository ID of interface
  public String[] _ids() {
    return myIds; 
  }

} 
// File DSIServer.java continues
</PRE
 

<P>Here is the remainder of DSIServer.java, showing a standard server 
implementation. Note that you register a dynamic servant with the ORB by 
using the same operation you would for a static servant. 

<PRE>
// Java

// DSIServer implementation
public class DSIServer {

  // Main
  public static void main(String[] args) {
    try {
      // Access and initialize the ORB
      org.omg.CORBA.ORB orb = ORB.init(args, null);

      // Create an instance of the dynamic implementation
      DSIExampleServantImpl servant = new DSIExampleServantImpl(orb);

      // Register the dynamic servant with the ORB
      orb.connect(servant);

      // Write IOR into file. 
      // Alternatively, the naming service could be used.
      OutputStream f = new FileOutputStream(
            System.getProperty("user.home") + 
	    System.getProperty("file.separator") + "DSI.ior") ;
      DataOutputStream out = new DataOutputStream(f) ;
      String ior = orb.object_to_string(servant) ;
      out.writeBytes(ior) ;
      out.close();

      System.out.println("IOR is " + ior) ;

      // Wait for requests from client
      java.lang.Object sync = new java.lang.Object();
      synchronized(sync){
        sync.wait();
      }

    } 
    catch (Exception ex) {
      ex.printStackTrace();
      System.err.println("DSIServer: Exception thrown: " + ex);
    }   
  }
}
</PRE> 

<A name="ties">
<H2>Delegation-based Skeletons (Ties)</H2></A>

<P>Because Java allows a class to inherit implementation from only a single
superclass, it is sometimes awkward to provide CORBA object implementations for
objects that rightfully belong in a class hierarchy--the servant base class
occupies the single available superclass position. These objects can become
CORBA servants most easily by use of delegation-based skeletons.

<P>Delegation-based skeletons move the required CORBA operations from a servant
base class (from which your object must inherit) to the generated <KBD>Tie</KBD>
class. The <KBD>Tie</KBD> class acts as the skeleton for this object, receiving
invocations from the ORB and delegating them to the servant that actually does 
the work.

<P><strong>Note:</strong> 
You will need to
<a href="http://developer.javasoft.com/developer/earlyAccess/jdk12/idltojava.html">download the idltojava compiler</a> before you can perform
the IDL compilation steps described in the following sections.

<A name="usingties">
<H3>Using Ties</H3>

<P>To use ties, first compile the IDL interface using the 
<KBD>-ftie</KBD></A> flag. In addition to
the usual Java files, this command also produces an <KBD>Operations</KBD>
interface and a <KBD>Tie</KBD> class. Then write your class, 
implementing the generated <KBD>Operations</KBD> interface.

<A name="tiesexample">
<H3>Ties Example</H3>

Consider the following simple IDL interface:

<PRE>
// IDL
interface Frog{
  void croak();
};
</PRE>

<P>Compiling Frog.idl with idltojava generates the standard client and 
server files (servant classes, etc.) and the special files for delegation-based 
skeletons: _FrogTie and _FrogOperations.
The standard implementation of this IDL looks like this:

<PRE>
// FrogImpl.java--without using ties, inherits required
// CORBA functionality from _FrogImplBase
<B>
public class FrogImpl extends _FrogImplBase {</B>
  public void croak() {
    getAudioClip(getCodeBase(), "frog.au").play();
  }
  
  public static void main(String[] args) {
    ORB orb = ORB.init();<B>
    Frog frogRef = new FrogImpl();
    orb.connect(frogRef);</B>
    // remainder of code deleted 
  }
}
</PRE>

<P>Note that, because FrogImpl.java inherits its CORBA functionality
(such as the dispatch upcall from the ORB) from _FrogImplBase, it must contain
the implementation code for the rest of its methods; it cannot
inherit them even if they are identical to those in another class.

<P>The same class, using a delegation-based skeleton, would look
like this:

<PRE>
// Amphibian.java--provides general behavior

public class Amphibian extends Applet {
  public void breathWater(){
    // implementation deleted
  }
}

// FrogImpl.java--using ties
<B>
public class FrogImpl extends Amphibian implements _FrogOperations {</B>
  public void croak() {
    // croak method must still be here; it is in the Operations interface
    getAudioClip(getCodeBase(), "frog.au").play();
  }
  
  public static void main(String[] args) {
    ORB orb = ORB.init();<B>
    FrogImpl servant = new FrogImpl();
    Frog frogRef = new _FrogTie(servant);
    orb.connect(frogRef);</B>
    // remainder of code deleted 
  }
}
</PRE>

<P>Using ties, FrogImpl reserves its superclass slot for inheritance
of amphibian behavior while implementing the CORBA operations defined in 
the IDL interface (and in _FrogOperations). 

<P>Note the difference in the <KBD>orb.connect()</KBD> call. With a 
delegation-based skeleton, you pass a new tie class instance to the 
ORB, rather than passing the actual object implementation.


<P><HR>
<CENTER><P>
<A href="jidlClients.html">Clients</A> | Servers | <A 
href="jidlExceptions.html">Exceptions</A> | <A 
href="jidlInitialization.html">Initialization</A> | <A 
href="jidlNaming.html">Naming</A> 


<TABLE cellpadding=8 cellspacing=4>
<TR>
  <TD ALIGN=CENTER><A href="index.html"><IMAGE 
SRC="images/1top_lt.gif"><BR>Home</A></TD>
  <TD ALIGN=CENTER><A href="fund.html"><IMAGE 
SRC="images/2fundamentals_lt.gif"><BR>Fundamentals</A></TD>  
  <TD ALIGN=CENTER><A href="program.html"><IMAGE 
SRC="images/3programming_lt.gif"><BR>Programming</A></TD>  
  <TD ALIGN=CENTER><A href="reference.html"><IMAGE 
SRC="images/4ref_lt.gif"><BR>References</A></TD>  
  <TD ALIGN=CENTER><A href="examples.html"><IMAGE 
SRC="images/4ex_lt.gif"><BR>Tutorial</A>
</TD>
</TR></TABLE>

<HR><FONT
SIZE="-2">
<A HREF="http://www.sun.com/share/text/SMICopyright.html">Copyright
&copy;</A></FONT><FONT SIZE="-2"> 1996, 1997 Sun Microsystems, Inc.,
2550 Garcia Ave., Mtn. View, CA. 94043-1100 USA., All rights
reserved.</FONT></P>
</CENTER>
</BODY>
</HTML>
