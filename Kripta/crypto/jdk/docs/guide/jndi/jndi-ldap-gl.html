<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.6 [en] (X11; I; SunOS 5.7 sun4u) [Netscape]">
   <title>JNDI/LDAP Supplement: Guidelines for LDAP Service Providers</title>
</head>
<body bgcolor="#FFFFFF">

<h1>

<hr SIZE=3 NOSHADE WIDTH="100%"></h1>

<center>
<h1>
JNDI Implementor Guidelines for LDAP Service Providers</h1></center>

<center>
<h1>
Draft 0.2</h1></center>

<hr SIZE=3 NOSHADE WIDTH="100%">
<p><font size=-1>Please send feedback to <font color="#CC0000"><a href="mailto:jndi@java.sun.com">jndi@java.sun.com</a></font></font>
<dl>
<dt>
<b>Table of Contents</b></dt>

<dt>
&nbsp;</dt>

<dt>
<b><a href="#INTRO">1. Introduction</a></b></dt>

<dt>
<b><a href="#CONF">2. Conformance</a></b></dt>

<dt>
<b><a href="#PROP">3. Environment Properties</a></b></dt>

<dt>
<b><a href="#NAMES">4. Names</a></b></dt>

<dt>
<b><a href="#ATTRS">5. Attributes</a></b></dt>

<dt>
<b><a href="#ATTRS">6. URLs</a></b></dt>

<dt>
<b><a href="#OBJ">7. Java Objects</a></b></dt>

<dt>
<b><a href="#SCHEMA">8. Schema</a></b></dt>

<dt>
<b><a href="#EXCEPT">9. Exceptions</a></b></dt>

<dt>
<b><a href="#API">10. API Mapping</a></b></dt>

<dt>
<b><a href="#FED">11. Federation</a></b></dt>

<dt>
<b><a href="#SASL">12. SASL</a></b></dt>

<dt>
<b><a href="#CTL">13. Extensions and Controls</a></b></dt>

<dt>
<b><a href="#EVENT">14. Event Notification</a></b></dt>

<dt>
<b><a href="#SSL">15. SSL</a></b></dt>
</dl>

<dd>
&nbsp;</dd>

<p>
<hr><a NAME="INTRO"></a>
<h2>
1. Introduction</h2>
This document specifies guidelines that developers creating LDAP service
providers and service providers that support LDAP-like features should
follow. By following these guidelines, developers can produce implementations
that JNDI API users can configure and use with minimal differences.
<p>Not all of the features described in this document must be supported
by an LDAP service provider. However, if a feature is supported, it should
be supported in the way described by this document.
<p>
<hr>
<br><a NAME="CONF"></a>
<h2>
2. Conformance</h2>
An LDAP service provider that supports LDAP version 3 (LDAPv3) conforms
to:
<ul>
<li>
&nbsp;<a href="http://www.ietf.org/rfc/rfc2251.txt">RFC-2251</a> and related
specifications.</li>
</ul>
An LDAP service provider that supports LDAP version 2 (LDAPv2) conforms
to:
<ul>
<li>
&nbsp;<a href="http://www.ietf.org/rfc/rfc1777.txt">RFC-1777</a>&nbsp;
and related specifications.</li>
</ul>

<hr><a NAME="PROP"></a>
<h2>
3. Environment Properties</h2>
Environment properties are the means by which JNDI application users configure
and affect the behavior of JNDI service providers. Consequently, service
providers must interpret and handle environment properties in the same
way.
<p>
There are four types of environment properties that affect LDAP
service providers:
<ul>
<li>
<a href="#JNDIPROPS">Standard JNDI environment properties</a></li>

<li>
<a href="#LDAPPROPS">LDAP-specific environment properties</a></li>

<li>
<a href="#SPIPROPS">Provider-specific environment properties</a></li>

<li>
<a href="#SPIPROPS">Feature-specific environment properties</a></li>
</ul>

<h3>
3.1 Overview</h3>

<h4>
3.1.1 Initialization</h4>
When creating an initial context, environment properties can be passed
as an argument to the constructor or may be initialized as specified in the
<a href="../../api/javax/naming/InitialContext.html#ENVIRONMENT">JNDI
documentation</a>.
<p>In particular, if any of the following properties is not supplied in
the environment properties then it is sought from the system properties,
applet parameters, and both provider and application resource files (in
that order):
<ul>
<li>
<tt><a href="#control">java.naming.factory.control</a></tt></li>

<li>
<tt><a href="#initial">java.naming.factory.initial</a></tt></li>

<li>
<tt><a href="#object">java.naming.factory.object</a></tt></li>

<li>
<tt><a href="#state">java.naming.factory.state</a></tt></li>

<li>
<tt><a href="#url">java.naming.provider.url</a></tt></li>
</ul>
In the case of the control, object and state factory properties, 
if more than one occurrence of the property is located,
then its values are concatenated into a single list. 
In the case of the url property and all other
properties, only the first occurrence is used.
<p>A context's environment properties can be examined using the <tt>
<a href=
"../../api/javax/naming/Context.html#getEnvironment()">Context.getEnvironment</a></tt>
method.
<h4>
3.1.2 Modification</h4>
A context's environment properties may be changed using the <tt><a href=
"../../api/javax/naming/Context.html#addToEnvironment(java.lang.String, java.lang.Object)">Context.addToEnvironment</a></tt>
and <tt>
<a href=
"../../api/javax/naming/Context.html#removeFromEnvironment(java.lang.String)">Context.removeFromEnvironment</a></tt>
methods.
<h4>
3.1.3 Scope</h4>
With the exception of the
<tt><a href=
"../../api/javax/naming/Context.html#PROVIDER_URL">java.naming.provider.url</a></tt>
and
<tt><a href=
"../../api/javax/naming/Context.html#INITIAL_CONTEXT_FACTORY">java.naming.factory.initial</a></tt>
properties, changing a property using the <tt>
<a href=
"../../api/javax/naming/Context.html#addToEnvironment(java.lang.String, java.lang.Object)">Context.addToEnvironment</a></tt>
or <tt>
<a href=
"../../api/javax/naming/Context.html#removeFromEnvironment(java.lang.String)">Context.removeFromEnvironment</a></tt>
methods affects the context instance on which the method is invoked. For
example, if you specify new credentials for a context to use, subsequent
methods invoked on that context that require communication with the server
will use those new credentials (perhaps internally by first creating a
new connection to the server). These updated environment properties are
inherited by context instances that are subsequently derived from the affected
context instance, but do not otherwise affect other context instances that
were in existence prior to the update.
<h4>
3.1.4 Timeliness</h4>
When a change is made to the environment properties, there is no requirement
that the change be verified and acted upon at the time the&nbsp; <tt>
<a href=
"../../api/javax/naming/Context.html#addToEnvironment(java.lang.String, java.lang.Object)">
Context.addToEnvironment</a></tt>
or <tt>
<a href=
"../../api/javax/naming/Context.html#removeFromEnvironment(java.lang.String)">Context.removeFromEnvironment</a></tt>
method is invoked. The only requirement is that the change (or changes)
be effective the next time an operation that uses that property is invoked.
<h4>
3.1.5 Defaults</h4>
This specification defines defaults for the environment properties. In
a few cases, the default is determined by the service provider. If a context
does not have a particular environment property, it behaves as if it has
that environment property with its default value.
<p>When a property is removed from the environment properties of a context,
the context assumes the default behavior specified for that property. This
does not necessarily mean that the default value must be recorded as the
property's value. The removal may also be indicated by the absence of the
property from the context's environment properties.
<h4>
3.1.6 Acceptable Values</h4>
This specification defines acceptable values for the environment properties.
Some environment properties have a fixed set of acceptable values while
others have values that must follow a particular syntax. If an unacceptable
value is presented, a property-specific exception will be thrown (for example,
<tt>
<a href=
"../../api/javax/naming/ConfigurationException.html">ConfigurationException</a></tt>,
<tt><a
href="../../api/java/lang/IllegalArgumentException.html">IllegalArgumentException</a></tt>,
or <tt><a
href=
"../../api/javax/naming/AuthenticationNotSupportedException.html">AuthenticationNotSupportedException</a></tt>). 
In some cases, it might
be reasonable for the service provider to accept additional values than
those specified, in which case, those values should be documented.
<p><a NAME="JNDIPROPS"></a>
<h3>
3.2 JNDI Properties</h3>
LDAP service providers should process the JNDI environment properties according
to the following specifications. In the examples given, <tt>env</tt> is
an instance of <tt><a href=
"../../api/java/util/Hashtable.html">Hashtable</a></tt>
that holds the environment properties used to create an initial context.
<p>
<a NAME="batchsize"></a>
<dt>
<b><tt>java.naming.batchsize</tt></b></dt>

<blockquote>The value of this property is a string of decimal digits that
specifies the batch size of search results returned by the server.
<p>This property affects the blocking behaviour of the <tt>Context.list</tt>,
<tt>Context.listBindings</tt>,
and <tt>DirContext.search</tt> methods and the <tt>NamingEnumeration</tt>
objects that they return. It does not affect how many items are returned
in the enumeration; it only affects how the items are batched or read at
the LDAP protocol level.
<p>A setting of zero means that the provider should block until all results
have been received. A setting of an integer <i>n</i> greater than zero
means that the provider should block until <i>n</i> results have been received
from the server or until the enumeration terminates, whichever produces
the fewer number of results. After the application has read
<i>n</i> results
(using <tt>NamingEnumeration.next</tt> or <tt>NamingEnumeration.nextElement</tt>),
the provider should read <i>n</i> more results from the server or until
the enumeration terminates, whichever produces the fewer number of results.
<p>If this property is not set then its default value is implementation-specific.
<p>
For example,
<blockquote>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#BATCHSIZE">
Context.BATCHSIZE</a>, "24");</pre>
</blockquote>
specifies that the provider should block until 24 entries have been read
from the server or until the enumeration terminates, whichever produces
the fewer number of results.
</blockquote>
<a NAME="control"></a>
<dt>
<b><tt>java.naming.factory.control</tt></b></dt>

<blockquote>The value of this property is a colon-separated list of fully
qualified class names of control factory classes.
<p>The factories are responsible for <i>narrowing</i> the class of reponse
controls. They create specific response controls from the generic response
controls generated by the provider.
<p>No default value is defined for this property.
<p>For example,
<blockquote>
<pre>env.put(<a href=
"../../api/javax/naming/ldap/LdapContext.html#CONTROL_FACTORIES">LdapContext.CONTROL_FACTORIES</a>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "com.sun.jndi.ldap.ctl.ResponseControlFactory");</pre>
</blockquote>
sets the <tt>ResponseControlFactory</tt> class as the control factory to
try.</blockquote>
<a NAME="initial"></a>
<dt>
<b><tt>java.naming.factory.initial</tt></b></dt>

<blockquote>The value of this property is the fully qualified class name
of the factory class which creates the initial context for the LDAP service
provider.
<p>It is used to select a particular LDAP service provider; it's not actually
used by the provider itself. This property need not be set when the name
argument to initial context methods is a URL.
<p>No default value is defined for this property.
<p>For example,
<blockquote><tt>env.put(<a href=
"../../api/javax/naming/Context.html#INITIAL_CONTEXT_FACTORY">Context.INITIAL_CONTEXT_FACTORY</a>,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "com.sun.jndi.ldap.LdapCtxFactory");</tt></blockquote>
selects Sun's LDAP provider.</blockquote>
<a NAME="object"></a>
<dt>
<b><tt>java.naming.factory.object</tt></b></dt>

<blockquote>The value of this property is a colon-separated list of fully
qualified class names of object factory classes.
<p>The factories are responsible for creating specific objects from the
LDAP entries returned by the provider. For example, a Person object factory
might generate a <tt>Person</tt> object from an LDAP entry of object class
person. Object factories behave in the opposite way to <a href="#state">state
factories</a> in that they generate objects from LDAP attributes.
<p>No default value is defined for this property.
<p>For example,
<blockquote>
<pre>env.put(<a href=
"../../api/javax/naming/ldap/LdapContext.html#CONTROL_FACTORIES">Context.OBJECT_FACTORIES</a>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "com.sun.jndi.ldap.obj.PersonFromLDAP");</pre>
</blockquote>
sets the <tt>PersonFromLDAP</tt> class as the object factory to try.</blockquote>
<a NAME="state"></a>
<dt>
<b><tt>java.naming.factory.state</tt></b></dt>

<blockquote>The value of this property is a colon-separated list of fully
qualified class names of state factory classes.
<p>The factories are responsible for creating an object's state (for storing)
from the object itself. For example, a Person state factory might generate
an LDAP entry of object class person from a <tt>Person</tt> object. State
factories behave in the opposite way to <a href="#object">object factories</a>
in that they generate LDAP attributes from objects.
<p>No default value is defined for this property.
<p>For example,
<blockquote>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#STATE_FACTORIES">Context.STATE_FACTORIES</a>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "com.sun.jndi.ldap.obj.PersonToLDAP");</pre>
</blockquote>
sets the <tt>PersonToLDAP</tt> class as the state factory to try.</blockquote>
<a NAME="language"></a>
<dt>
<b><tt>java.naming.language</tt></b></dt>

<blockquote>The value of this property is a string language tag according
to <a href="http://www.ietf.org/rfc/rfc1766.txt">RFC-1766</a>.</blockquote>

<dl>
<dl>This property indicates a preference for a particular natural language.
A provider may adjust its LDAP requests and responses according to the
value of this property.
<p>The affect of this property is implementation-specific. No default value
is defined.
<p>For example:
<dl>
<pre><tt>env.put(<a href=
"../../api/javax/naming/Context.html#LANGUAGE">Context.LANGUAGE</a>,
"ja-JP");</tt></pre> </dl>
indicates a preference for Japanese.</dl>
</dl>
<a NAME="url"></a>
<dt>
<b><tt>java.naming.provider.url</tt></b></dt>

<blockquote>The value of this property is a URL string that specifies the
hostname and port number of the LDAP server, and the root distinguished
name of the naming context to use.
<p>See <a href="#URL">LDAP URL</a> for information on how to treat other
information found in the URL.
<p>The default hostname is <tt>localhost</tt>; the default port is <tt>389</tt>.
The default root distinguished name is the empty string.
If this property is not set, or if either the hostname or port number is
omitted, then the default values are used in place of the missing information.
<p>For example:
<blockquote>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#PROVIDER_URL">Context.PROVIDER_URL</a>,
"ldap://secserver:636");</pre>
</blockquote>
specifies that the LDAP server is running on a host named <tt>secserver</tt>
at port
<tt>636</tt>.
<p><b>NOTE:</b> Changing this property using the <tt><a href=
"../../api/javax/naming/Context.html#addToEnvironment(java.lang.String, java.lang.Object)">Context.addToEnvironment</a></tt>
or <tt><a
href="../../api/javax/naming/Context.html#removeFromEnvironment(java.lang.String)">Context.removeFromEnvironment</a></tt>
methods does not affect the context. It is only used by the initial context
constructors.</blockquote>
<a NAME="referral"></a>
<dt>
<b><tt>java.naming.referral</tt></b></dt>

<blockquote>The value of this property is a string that specifies how referrals
shall be handled by the provider. The following values are defined for
this property:</blockquote>

<dl>
<dl>
<dl>
<dt>
<tt>follow</tt></dt>

<dd>
automatically follow any referrals.</dd>

<dt>
<tt>throw</tt></dt>

<dd>
throw a <tt><a href=
"../../api/javax/naming/ReferralException.html">ReferralException</a></tt>
for each referral.</dd>

<dt>
<tt>ignore</tt></dt>

<dd>
ignore referrals if they appear in results. A <tt><a href=
"../../api/javax/naming/PartialResultException.html">PartialResultException</a></tt>
is thrown to indicate an incomplete result. In addition, for LDAPv3 servers,
the provider shall request that referrals be treated as ordinary attributes
when they appear in entries. This is achieved by sending a non-critical
ManageDsaIT (<tt>draft-ietf-ldapext-namedref-00.txt</tt>).  
LDAP control with each LDAP request. LDAP servers which do not support
this LDAP control will simply ignore it and process the request as normal.</dd>
</dl>

<p>See <a href="#URL">LDAP URL</a> for information on how to treat
multiple URLs found in a single referral entry.
<p>If this property is not set then its default value is <tt>ignore</tt>.
<p>For example:
<dl>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#REFERRAL">Context.REFERRAL</a>,
"throw");</pre>
</dl>
specifies that referrals encountered during an LDAP operation should throw
a <tt><a href=
"../../api/javax/naming/ReferralException.html">ReferralException</a></tt>
to the application.</dl>
</dl>
<a NAME="authentication"></a>
<dt>
<b><tt>java.naming.security.authentication</tt></b></dt>

<blockquote>The value of this property is a string that specifies the authentication
mechanism(s) for the provider to use. The following values are defined
for this property:</blockquote>

<dl>
<dl>
<dl>
<dt>
<tt>none</tt></dt>

<dd>
use no authentication (anonymous bind).</dd>

<dt>
<tt>simple</tt></dt>

<dd>
use simple authentication (a cleartext password).</dd>

<dt>
<i>A space-separated list of one or more SASL mechanism names</i>:</dt>

<dd>
use the first available SASL mechanism in the list.</dd>
</dl>

<p>See <a href="#SASL">SASL</a> for information on how this property
is used for SASL authentication. See&nbsp; 
<a href=
"http://www.ietf.org/internet-drafts/draft-ietf-ldapext-authmeth-04.txt">
draft-ietf-ldapext-authmeth-04</a>&nbsp;
for information on LDAP authentication mechanisms.
<p>If this property is not set then its default value is <tt>none</tt>,
unless the <a href="#credentials">java.naming.security.credentials</a>
property is set, in which case the default value is <tt>simple</tt>. If
this property is set to a value that the provider does not recognize or
support, it should throw <tt>AuthenticationNotSupportedException</tt>.
<p>For example:
<dl>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#SECURITY_AUTHENTICATION">Context.SECURITY_AUTHENTICATION</a>,
"simple");</pre>
</dl>
specifies that simple authentication be used to authenticate to the LDAP
server. Or,
<dl>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#SECURITY_AUTHENTICATION">Context.SECURITY_AUTHENTICATION</a>,
"DIGEST-MD5 CRAM-MD5");</pre>
</dl>
specifies that DIGEST-MD5 authentication be used or, if that SASL mechanism
is unavailable, that CRAM-MD5 authentication be used. If neither is available
then throw <tt>AuthenticationNotSupportedException</tt>.</dl>
</dl>
<a NAME="credentials"></a>
<dt>
<b><tt>java.naming.security.credentials</tt></b></dt>

<dl>
<dl>The value of this property is an object that specifies the credentials
of the principal to be authenticated. Its format and handling depends on
the value of the&nbsp; <a href="#authentication">java.naming.security.authentication</a>
property.
<p>For anonymous binds, this property is ignored - an empty string is always
used for the credentials. For simple authentication, and for SASL mechanisms
such as CRAM-MD5 that require a password, the value of this property may
be supplied as a <tt>java.lang.String</tt>, a <tt>char[]</tt> or a <tt>byte[]</tt>.
If it is a <tt>String</tt> or a <tt>char[]</tt> then it is encoded into
a byte array using UTF-8 in the case of LDAPv3 and encoded using ISO-Latin-1
in the case of LDAPv2. If it is a <tt>byte[]</tt> then it is used as is.
<p>See <a href="#SASL">SASL</a> for information on how this property is
used for SASL authentication.
<p>No default value is defined for this property.
<p>For example:
<dl>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#SECURITY_CREDENTIALS">Context.SECURITY_CREDENTIALS</a>,
"secret");</pre>
</dl>
sets the credentials to be the string "secret".</dl>
</dl>
<a NAME="principal"></a>
<dt>
<b><tt>java.naming.security.principal</tt></b></dt>

<blockquote>The value of this property is a string that specifies the identity
of the principal to be authenticated. Its format is a string distinguished
name (<a href="http://www.ietf.org/rfc/rfc2253.txt">RFC-2253</a>). The
value is used as the <tt>name</tt> component in an LDAP ASN.1 BindRequest.
<p>If the <a href="#authorizationId">java.naming.security.sasl.authorizationId</a>
property is not set then the value of the principal property
is also used as the authorization identity by SASL mechanisms. 
<p>The provider is not required to verify the validity of the principal
name. It may, for example, just pass the string to be verified by the server.
If the principal identified is not a valid principal then the provider
shall throw an <tt>AuthenticationException</tt>.
<p>No default value is defined for this property.
<p>For example:
<blockquote>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#SECURITY_PRINCIPAL">Context.SECURITY_PRINCIPAL</a>,
"cn=admin,o=sun,c=us");</pre>
</blockquote>
sets the principal name to be the distinguished name "cn=admin, o=sun,
c=us".</blockquote>
<a NAME="protocol"></a>
<dt>
<b><tt>java.naming.security.protocol</tt></b></dt>

<dl>
<dl>The value of this property is a string that specifies the security
protocol for the provider to use. The following value is defined for this
property:
<br>&nbsp;
<dl>
<dt>
<tt>ssl</tt></dt>

<dd>
use Secure Sockets Layer version 3.0.</dd>
</dl>

<p>If this property is set to <tt>ssl</tt>, the provider must use SSL
sockets, or throw <tt>ConfigurationException</tt> if it is unable to do
so. In addition to the value listed above, a provider may support other
security protocols. However, such provider-specific protocols might not
be supported by all providers. If this property is set to a security protocol
that the provider does not recognize or support, it should throw
<tt>ConfigurationException</tt>.
<p>If the&nbsp; <a href="#protocol">java.naming.ldap.factory.socket</a>&nbsp;
property is set, then the socket factory identified by that property must
create sockets that are appropriate for this protocol setting. For example,
if the security protocol is set to <tt>ssl</tt>, then the socket factory
must create SSL-compliant sockets.
<p>If this property is not set then the default is to use no security protocol.
<p>As a developer of the LDAP provider, you should be aware that using
SSL to connect to a server on a port that is not listening for SSL connections
causes the socket to hang. Similarly, using a plain socket to connect to
a server that is listening for SSL connections also leads to hanging. This
is a characteristic of the protocol that some implementations may choose
to correct but is not otherwise required to do so. The provider's documentation,
however, should describe this behavior to its users. See <a href="#SSL">SSL</a>
for information on how to use SSL.
<p>For example:
<dl>
<pre>env.put(<a href=
"../../api/javax/naming/Context.html#SECURITY_PROTOCOL">Context.SECURITY_PROTOCOL</a>,
"ssl");</pre>
</dl>
specifies that SSL-compliant sockets be used to communicate with the server.</dl>
</dl>
<a NAME="LDAPPROPS"></a>
<h3>
3.3 LDAP-specific Properties</h3>
LDAP-specific properties are environment properties that apply to LDAP
service providers in general. These properties' names have the prefix "<tt>java.naming.ldap.</tt>".
The following table lists LDAP-specific properties that have been defined
so far. If there is a property that you feel belongs on this list, please
send a description of it to
<font color="#CC0000"><a href="mailto: jndi@java.sun.com">jndi@java.sun.com</a></font>.
<p>
<a NAME="binary"></a>
<dt>
<b><tt>java.naming.ldap.attributes.binary</tt></b></dt>

<dl>
<dl>The value of this property is a string of space-separated attribute
names. It specifies attributes which have non-string syntax. It extends
the provider's <i>built-in</i> list of non-string attributes (below). The
value of an attribute that has non-string syntax is returned as a byte array
(<tt>byte[]</tt>) instead of a <tt>String</tt>.
<p>No default is defined. If this property is not set then only the following
attributes are considered to have non-string syntax:</dl>

<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr NOSAVE>
<th NOSAVE>Attribute ID</th>

<th>OID</th>

<th NOSAVE>Reference</th>
</tr>

<tr>
<td>Any attribute ID with the "<tt>;binary</tt>" option.</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr NOSAVE>
<td><tt>photo</tt></td>

<td>0.9.2342.19200300.100.1.7</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc1274.txt">RFC-1274</a></td>
</tr>

<tr NOSAVE>
<td><tt>personalSignature</tt></td>

<td>0.9.2342.19200300.100.1.53</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc1274.txt">RFC-1274</a></td>
</tr>

<tr NOSAVE>
<td><tt>audio</tt></td>

<td>0.9.2342.19200300.100.1.55</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc1274.txt">RFC-1274</a></td>
</tr>

<tr>
<td><tt>jpegPhoto</tt></td>

<td>0.9.2342.19200300.100.1.60</td>

<td><a href=
"http://www.ietf.org/internet-drafts/draft-smith-ldap-inetorgperson-04.txt">
draft-smith-ldap-inetorgperson-04</a>
</td>
</tr>

<tr>
<td><tt>javaSerializedData</tt></td>

<td>1.3.6.1.4.1.42.2.27.4.1.7</td>

<td>
<a href="http://www.ietf.org/rfc/rfc2713.txt">RFC 2713</a>
</td>
</tr>

<tr NOSAVE>
<td><tt>thumbnailPhoto</tt></td>

<td>2.16.128.113533.1.1400.1</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.netapps.org">NAC LIP Schema</a></td>
</tr>

<tr NOSAVE>
<td><tt>thumbnailLogo</tt></td>

<td>2.16.128.113533.1.1400.2</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.netapps.org">NAC LIP Schema</a></td>
</tr>

<tr NOSAVE>
<td><tt>userPassword</tt></td>

<td>2.5.4.35</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>

<tr NOSAVE>
<td><tt>userCertificate</tt></td>

<td>2.5.4.36</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>

<tr NOSAVE>
<td><tt>cACertificate</tt></td>

<td>2.5.4.37</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>

<tr NOSAVE>
<td><tt>authorityRevocationList</tt></td>

<td>2.5.4.38</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>

<tr NOSAVE>
<td><tt>certificateRevocationList</tt></td>

<td>2.5.4.39</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>

<tr NOSAVE>
<td><tt>crossCertificatePair</tt></td>

<td>2.5.4.40</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>

<tr NOSAVE>
<td><tt>x500UniqueIdentifier</tt></td>

<td>2.5.4.45</td>

<td ALIGN=CENTER NOSAVE><a href="http://www.ietf.org/rfc/rfc2256.txt">RFC-2256</a></td>
</tr>
</table></center>
<p>
<dl>For example:
<dl>
<pre>env.put("java.naming.ldap.attributes.binary",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "mpegVideo myspecialkey");</pre>
</dl>
informs the provider to return values of the
<tt>mpegVideo</tt> and <tt>myspecialkey</tt> attributes as <tt>byte[]</tt>.
<a NAME="connect"></a></dl>

<p>
<dt>
<b><tt>java.naming.ldap.control.connect</tt></b></dt>
<p>
<dl>The value of this property is a <tt>Control[]</tt> object.&nbsp; It
sets the connection request controls that are active on a connection. See
<tt><a href=
"../../api/javax/naming/ldap/LdapContext.html">LdapContext</a></tt>.
<p>No default value is defined for this property.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.control.connect",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Control[]{ new ManageReferralControl(true) });</pre>
</dl>
sets a critical ManageDsaIT LDAP control as the connection request control.</dl>

<p>
<a NAME="deleteRDN"></a>
<dt>
<b><tt>java.naming.ldap.deleteRDN</tt></b></dt>
<p>

<dl>The value of this property is a string that specifies whether the old
RDN is removed by the <tt><a href=
"../../api/javax/naming/Context.html#rename(java.lang.String, java.lang.String)">
Context.rename</a></tt>
method. The following values are defined for this property:
<br>&nbsp;
<dl>
<dt>
<tt>true</tt></dt>

<dd>
delete the old RDN from the entry during the rename operation.</dd>

<dt>
<tt>false</tt></dt>

<dd>
retain the old RDN as an attribute value of the entry.</dd>

<br>&nbsp;</dl>
If this property is not set then its default value is <tt>true</tt>.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.deleteRDN", "false");</pre>
</dl>
causes the old RDN to be retained as an attribute of the renamed entry.</dl>
</dl>
<p>
<a NAME="derefAliases"></a>
<dt>
<b><tt>java.naming.ldap.derefAliases</tt></b></dt>

<blockquote>The value of this property is a string that specifies how aliases
are dereferenced during search operations. The following values are defined
for this property:</blockquote>

<blockquote>
<blockquote>
<dt>
<tt>always</tt></dt>

<dd>
always dereference aliases.</dd>

<dt>
<tt>never</tt></dt>

<dd>
never dereference aliases.</dd>

<dt>
<tt>finding</tt></dt>

<dd>
dereference aliases only during name resolution (that is, while locating
the target entry).</dd>

<dt>
<tt>searching</tt></dt>

<dd>
dereference aliases once name resolution has completed (that is, after
locating the target entry).</dd>
</blockquote>
</blockquote>

<blockquote>
<dl>If this property is not set then its default value is <tt>always</tt>.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.derefAliases", "searching");</pre>
</dl>
causes the provider to dereference aliases only once the target entry has
been located.
<p><b>NOTE</b>: this property is unrelated to the dereference-links flag
in the <tt><a href=
"../../api/javax/naming/directory/SearchControls.html">SearchControls</a></tt>
object.</dl>
</dl>
</blockquote>
<p>
<a NAME="socket"></a>
<dt>
<b><tt>java.naming.ldap.factory.socket</tt></b></dt>

<dl>
<dl>The value of this property is a string identifying the class name of
a socket factory.
<p>This property is used to override the default socket factory. The class
specified in this property must implement the <tt><a href="http://java.sun.com/security/ssl/javax.net.SocketFactory.html">javax.net.SocketFactory</a></tt>
interface. See <a href="http://java.sun.com/security/ssl/API_users_guide.html">http://java.sun.com/security/ssl/API_users_guide.html</a>
for more information. See <a href="#SSL">SSL</a> for information on how
to use SSL.
<p>In addition, if the&nbsp; <a href="#protocol">java.naming.security.protocol</a>&nbsp;
property is set, then the socket factory identified by this property must
create sockets which are appropriate for that protocol setting. For example,
if the security protocol is set to <tt>ssl</tt> then the socket factory must create
SSL-compliant sockets.
<p>No default is defined for this property.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.factory.socket",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "javax.net.ssl.SSLSocketFactory");</pre>
</dl>
sets the socket factory of the provider to be <tt>javax.net.ssl.SSLSocketFactory</tt>.</dl>
</dl>
<p>
<a NAME="separator"></a>
<dt>
<b><tt>java.naming.ldap.ref.separator</tt></b></dt>

<dl>
<dl>The value of this property is a string containing the character to
use when encoding a <tt><a href=
"../../api/javax/naming/RefAddr.html">RefAddr</a></tt>
object in the <tt>javaReferenceAddress</tt> attribute (see <a href="#OBJ">Java
Objects</a>).
<p>This property is used to avoid a conflict in the case where the default
separator character appears in the components of a <tt><a href=
"../../api/javax/naming/RefAddr.html">RefAddr</a></tt>
object.
<p>If this property is not set then its default value is '<tt>#</tt>' (the
hash character).
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.ref.separator", ":");</pre>
</dl>
specifies that the separator '<tt>:</tt>' (the colon character) be used
when storing <tt><a href=
"../../api/javax/naming/RefAddr.html">RefAddr</a></tt>
instances.</dl>
</dl>
<p>
<a NAME="limit"></a>
<dt>
<b><tt>java.naming.ldap.referral.limit</tt></b></dt>

<dl>
<dl>The value of this property is a string of decimal digits specifying
the maximum number of referrals to follow in a chain of referrals. A setting
of zero indicates that there is no limit.
<p>If this property is not set then the default value is <tt>10</tt>.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.referral.limit", "5");</pre>
</dl>
specifies that the referral limit is 5.</dl>
</dl>
<p>
<a NAME="typesOnly"></a>
<dt>
<b><tt>java.naming.ldap.typesOnly</tt></b></dt>

<dl>
<dl>The value of this property is a string that specifies whether only
attribute IDs are returned in results - attribute values are omitted. Affects
the <tt><a href=
"../../api/javax/naming/directory/SearchResult.html#getAttributes()">SearchResult.getAttributes</a></tt>
and <tt><a href=
"../../api/javax/naming/directory/DirContext.html#getAttributes(java.lang.String)">DirContext.getAttributes</a></tt>
methods.
The following values are defined for this property:
<br>&nbsp;
<dl>
<dt>
<tt>true</tt></dt>

<dd>
return only attribute IDs.</dd>

<dt>
<tt>false</tt></dt>

<dd>
return both attribute IDs and attribute values.</dd>
</dl>

<p>If this property is not set then its default value is <tt>false</tt>.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.typesOnly", "true");</pre>
</dl>
causes the server to return attribute IDs but not attribute values.</dl>
</dl>
<p>
<dt>
<a NAME="version"></a></dt>

<dt>
<b><tt>java.naming.ldap.version</tt></b></dt>

<dl>
<dl>The value of this property is a string that specifies the protocol
version for the provider. The following values are defined for this property:
<br>&nbsp;
<dl>
<dt>
<tt>2</tt></dt>

<dd>
selects LDAP version 2 (LDAPv2).</dd>

<dt>
<tt>3</tt></dt>

<dd>
selects LDAP version 3 (LDAPv3).</dd>
</dl>

<p>If this property is not set then the provider first attempts to
bind using LDAP v3 and fails over to using LDAP v2 if a protocol error
is received from the server. This failover mechanism is only used when
the <tt><a href="#authentication">java.naming.security.authentication</a></tt>
property indicates anonymous bind or simple authentication.
<p>For example:
<dl>
<pre>env.put("java.naming.ldap.version", "2");</pre>
</dl>
requests the LDAP provider to communicate with the server using LDAPv2.</dl>
</dl>

<h3>
<a NAME="FEATUREPROPS"></a></h3>

<h3>
3.4 Feature-specific Properties</h3>
Feature-specific properties are environment properties which apply to a
particular feature which is supported by a provider.
<h4>
<a NAME="SASLPROPS"></a>
3.4.1 SASL Properties</h4>
<p>
<a NAME="authorizationId"></a>
<b><tt>java.naming.security.sasl.authorizationId</tt></b>
<blockquote>The value of this property is a string that specifies the authorization
ID for SASL mechanisms.
<p>If this property is not set then the value of the 
<a href=#principal><tt>java.naming.security.principal</tt></a>
property is used as the authorization ID.
<p>For example:
<dl>
<dl>
<pre>env.put("java.naming.security.sasl.authorizationId",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "dn:cn=administrators,ou=groups,o=sun,c=us");</pre>
</dl>
</dl>
specifies the identity to use for authorization (access control)
upon successful authentication.</blockquote>
<a NAME="callback"></a>
<br><b><tt>java.naming.security.sasl.callback</tt></b>
<blockquote>The value of this property is an instance of 
<a href=http://java.sun.com/security/jaas/apidoc/javax/security/auth/callback/CallbackHandler.html><tt>javax.security.auth.callback.CallbackHandler</tt></a>.
When the provider uses a SASL mechanism
that requires callbacks, the SASL mechanism uses the object supplied in
the property. The callback handler should satisfy a 
<a href=http://java.sun.com/security/jaas/apidoc/javax/security/auth/callback/NameCallback.html><tt>NameCallback</tt></a> by supplying the authentication ID.

<p>If this property is not set then the provider should use a default callback
handler that satisfies the 
<a href=http://java.sun.com/security/jaas/apidoc/javax/security/auth/callback/NameCallback.html><tt>NameCallback</tt></a>
using the value of the
<a href=#principal><tt>java.naming.security.principal</tt></a>
property, and satisfies the 
<a href=http://java.sun.com/security/jaas/apidoc/javax/security/auth/callback/PasswordCallback.html><tt>PasswordCallback</tt></a> using the value of
the <a href=#credentials><tt>java.naming.security.credentials</tt></a> property. 
<p>For example:
<dl>
<dl>
<pre>env.put("java.naming.security.sasl.callback",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MyCallbackHandler());</pre>
</dl>
</dl>
supplies an instance of the callback handler for SASL mechanisms to use.</blockquote>
<a NAME="pkgs"></a>
<br><b><tt>javax.security.sasl.client.pkgs</tt></b>
<blockquote>The value of this property is a '<tt>|</tt>'-separated list
of package names used to locate factories that produce SASL mechanism drivers. 
See the <a href=#SASL>SASL Section</a> and the
Java SASL API,
<a href="http://www.ietf.org/internet-drafts/draft-weltman-java-sasl-03.txt">draft-weltman-java-sasl-03</a></td>, for details.
</blockquote>
<a NAME="SPIPROPS"></a>
<h3>
3.5 Provider-specific Properties</h3>
Provider-specific properties are environment properties which apply only
to particular provider implementations. The names of these properties are
chosen by the provider's implementor. The recommended policy for naming
these properties is to use the implementor's reversed DNS domain name to
prefix the provider's package name and to use that package name to prefix
the property name. For example, Sun prefixes its provider-specific LDAP
properties with "<tt>com.sun.jndi.ldap</tt>".
<p>
<hr>
<a NAME="NAME"></a>
<h2>
4. Names</h2>
Names are handled by the provider's context methods according to the following
rules:
<ol>
<li>
<tt>String</tt> names supplied as parameters to the context methods are in the 
<a href=
"../../api/javax/naming/CompositeName.html">composite name
syntax</a>.</li>
The first component of the composite name is
an LDAP distinguished name
while the rest of the components are used for federation.

<li>
If a <tt>Name</tt> argument is a <tt>CompositeName</tt> object then its
first component is assumed to be an LDAP distinguished name and the remaining
components (if any) are used for federation.</li>

<li>
If a <tt>Name</tt> argument is <i>not</i> a <tt>CompositeName</tt> object
then all of its components are assumed to be the parsed form of an LDAP
distinguished name. That is, each <tt>Name</tt> component is an LDAP relative
distinguished name (RDN).</li>

<li>
Names are parsed using the name parser returned by the <tt>Context.getNameParser</tt>
method. The parser accepts LDAP distinguished names as <tt>String</tt>
objects and produces LDAP distinguished names as <tt>Name</tt> objects.</li>

<li>
Names returned by context operations are string composite names or string URLs.
</li>
</ol>
The syntax of string LDAP distinguished names follows <a href="http://www.ietf.org/rfc/rfc2253.txt">RFC-2253</a>.
For example:
<blockquote>
<li>
<tt>CN=Steve Kille, O=Isode Limited, C=GB</tt></li>

<li>
<tt>OU=Sales+CN=J. Smith, O=Widget Inc., C=US</tt></li>

<li>
<tt>CN=L. Eagle, O=Sue\, Grabbit and Runn, C=GB</tt></li>
</blockquote>
The name supplied to an LDAP context is always relative to that context.
For example, given an LDAP context (<tt>lctx</tt>) for "<tt>dc=widget,dc=com</tt>",
in order to name LDAP entries in that subtree, a name relative to "<tt>dc=widget,dc=com</tt>"
must be supplied. For example, the following call obtains the attributes
for the
<br>"<tt>cn=John Smith,dc=widget,dc=com</tt>" entry,
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>Attributes attrs = lctx.getAttributes("cn=John
Smith");</tt>
<p>Similarly, when a context is enumerated using any of the enumeration
methods (<tt>Context.list</tt>, <tt>Context.listBindings</tt>, <tt>DirContext.search</tt>),
the names returned are relative to the target context--the context being
enumerated.&nbsp; When referrals are invoked, instead of a relative name,
an LDAP URL string, containing the fully qualified name, is returned. The
format of LDAP URLs is defined in <a href="http://www.ietf.org/rfc/rfc2255.txt">RFC-2255</a>.
<p>LDAP URLs that follow <a href="http://www.ietf.org/rfc/rfc2255.txt">RFC-2255</a>
may be supplied to any of the context methods. The hostname and port number are
extracted from the URL and used to contact the LDAP server; the <tt><a href="#initial">java.naming.factory.initial</a></tt>
and <tt><a href="#url">java.naming.provider.url</a></tt> properties are
ignored. For example,
<p><tt>&nbsp;&nbsp;&nbsp; DirContext ictx = new InitialDirContext();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Attributes attrs = ictx.getAttributes(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ldap://wserver:389/cn=John
Smith,dc=widget,dc=com");</tt>
<p>
This code fragment contacts the LDAP server at machine <tt>wserver</tt>
at port <tt>389</tt>.
<p>
<hr>
<h2>
<a NAME="ATTRS"></a></h2>

<h2>
5. Attributes</h2>
<p>The LDAP provider expects as input and returns as output all attribute
values as either <tt>String</tt> or <tt>byte[]</tt> objects.&nbsp; See
the
<a href=#binary><tt>java.naming.ldap.attributes.binary</tt></a>
environment property for
which ones are treated as <tt>byte[]</tt> and how to extend the list. 
<p>
<hr>
<a NAME="URL"></a>
<h2>
6. URLs</h2>
<a href="http://www.ietf.org/rfc/rfc2255.txt">RFC-2255</a> describes the
syntactic format of LDAP URLs. The format contains all the elements necessary
to specify an LDAP search operation, with provisions for supporting extensions:
<blockquote>
<pre>ldap://host:port/dn?attributes?scope?filter?extensions</pre>
</blockquote>
Authentication information may be specified in the <tt>extensions</tt>
portion of the URL. See the RFC for a complete description of the format.
<p>URLs play a role in several places in JNDI:
<ol>
<li>
Configuration of service providers.</li>

<br>
To configure an LDAP service provider, you typically supply an LDAP
URL in the <a href=#url><tt>java.naming.provider.url</tt></a> property.
This is used by the LDAP service provider to configure its connection to
the directory server. Only the <tt>host</tt>, <tt>port</tt>, and <tt>dn</tt>
parts of the URL are relevant in this setting. Supplying other parts of
the URL results in a <tt>ConfigurationException</tt>.
<br>&nbsp;
<li>
Argument to initial context methods.</li>


<br>If a URL string (with syntax <i>scheme_id:rest_of_name</i>) is passed
to the methods in <tt>InitialContext</tt>, either as a <tt>String</tt>
argument or as the first component of <tt>Name</tt>, the URL's scheme id
is used to locate the context factory for handling that scheme. If none
is found, the URL string is treated as an ordinary name and passed to
the initial context specified by the 
<a href=#initial><tt>java.naming.factory.initial</tt></a>
property is used. See the <tt>java.naming.spi.NamingManager.getURLContext</tt>
method for details on how URL context factories are located.
Note that this support for LDAP URLs as names is only available in the initial
context.

<p>With the exception of the search methods, when an LDAP URL
is passed as a name to the initial context, the URL should <i>not</i> contain
any query ('<tt>?</tt>') components. Otherwise, an <tt>InvalidNameException</tt>
is thrown by the service provider. For the search methods, the query
components of the URL override any corresponding components supplied as
arguments. For example, if an LDAP URL containing a scope component is
supplied, then that scope overrides any scope setting that may be passed
in a <tt>SearchControls</tt> argument. 

<br>&nbsp;
<li>
Referrals.</li>

<br>An LDAP referral contains a list of one or more URLs. To process an
LDAP referral (either explicitly or implicitly by setting the 
<a href=#referral><tt>java.naming.referral</tt></a>
property), the service provider needs to use the information in the these
URLs to create connections to LDAP servers to which they refer. When multiple
LDAP URLs are present in a single referral they are treated as alternatives
and each is followed until one succeeds. The complete URL (that is, including
any query components) are used.
<br>&nbsp;
<li>
Returned as a name in list and search enumerations.</li>

<br>When the name of the entry being returned has a name that is not relative
to the target context (i.e., the starting context for the list or search),
the name is returned as a URL. See the <tt>NameClassPair.isRelative</tt>
method for details.
<br>&nbsp;
<li>
Argument to the <tt>getObjectInstance</tt> method of <tt>NamingManager</tt>
or <tt>DirectoryManager</tt>.
</li>

<br>When an LDAP namespace is federated underneath another namespace (for
example, such as DNS), the information that is stored in the superior namespace
might be an LDAP URL. In such a scenario, a lookup/list/search operation
in the superior namespace would return a <tt>Reference</tt> containing
an LDAP URL for the LDAP namespace.
The service provider for the superior namespace would pass the <tt>Reference</tt>
to the <tt>getObjectInstance</tt> method to create an instance of an LDAP
context.</ol>

<hr>
<br><a NAME="OBJ"></a>
<h2>
7. Java Objects</h2>

<h3>
7.1 Storing</h3>
The LDAP provider should support the storing of Java objects into the directory.
This is implemented in the following methods:
<ul>
<li>
<tt>Context.bind()</tt></li>

<li>
<tt>Context.rebind()</tt></li>

<li>
<tt>DirContext.bind()</tt></li>

<li>
<tt>DirContext.rebind()</tt></li>
</ul>
The provider should support at a minimum the storage of the following types
of Java objects:
<ol>
<li>
Instances of <tt>Reference</tt></li>

<li>
Objects that implement the <tt>Referenceable</tt> interface</li>

<li>
Objects that implement the <tt>Serializable</tt> interface</li>

<li>
Objects that implement the <tt>DirContext</tt> interface</li>
</ol>
It should check whether an object is in these four categories in the order
listed because that is most likely to capture the intent of the client.
For example, a <tt>Reference</tt> is <tt>Serializable</tt>, so if you performed
the <tt>Serializable</tt> check first, no
<tt>Reference</tt>s would ever
be stored in the reference format (that is, they would all be serialized).
<p>References, referenceable and serializable objects should be stored
according to <a href="http://www.ietf.org/rfc/rfc2713.txt">RFC 2713</a>.
<tt>DirContext</tt>
objects should be stored by storing their attributes. 
<p>
When storing a reference's
list of <tt>RefAddr</tt> into the 
<tt>javaReferenceAddress</tt> attribute, the separator
to use for delimiting the address's position, type and content are controlled
using the environment property 
<a href="#separator">java.naming.ldap.ref.separator</a>. 
If this environment property is not specified, the hash character '#'
should be used as the separator.
<p>The provider uses the <tt>DirectoryManager.getStateToBind</tt> method
when storing objects in the directory. This allows objects of any type
to be transformed into one of the four categories listed above so that
they can be stored into the directory.

<h3>
7.2 Reading</h3>
Objects are read from the directory using the following operations:
<ul>
<li>
<tt>Context.lookup()</tt></li>

<li>
<tt>Context.lookupLink()</tt></li>

<li>
<tt>Binding.getObject()</tt></li>
</ul>
When the provider reads an entry from the directory, it will get LDAP attributes,
and attributes defined in
<a href="http://www.ietf.org/rfc/rfc2713.txt">RFC 2713</a>
if the entry has an associated Java object. If the entry contains Java
object-related attributes, the provider should recreate the object using
those attributes. Otherwise, the provider should return an instance of
<tt>DirContext</tt>
containing the attributes of the entry. For both <tt>DirContext</tt> and
Java objects, the provider should then invoke <tt>DirectoryManager.getObjectInstance()</tt>
on it and return the result to the caller.
<p>
<hr>
<br><a NAME="SCHEMA"></a>
<h2>
8.0 Schema</h2>
JNDI does not specify schema-related details such as structure and contents
of the schema tree, permission to modify to the contents of the schema
tree, and the effect of such modifications on the directory are dependent
on the underlying directory. JNDI specifies only that the root schema context--that
returned by
<tt>DirContext.getSchema()</tt>--contain the following bindings:
<ul>
<li>
AttributeDefinition</li>

<li>
ClassDefinition</li>

<li>
SyntaxDefinition</li>
</ul>
This document specifies the structure and content of schema trees that
are derived from LDAP-based schemas. It describes how the schema tree is
laid out, and the mandatory and optional attributes that you can expect
to find associated with entries in different parts of this schema tree.
<p>Permission to modify the contents of the schema tree is determined by
the directory administrator. When the schema tree is modified, the changes
are made to schema stored on the directory server.
<h3>
8.1 Schema Tree Structure</h3>
In addition to the three bindings in the root schema context listed previously,
the root schema context may also contain the following four bindings:
<ul>
<li>
MatchingRule</li>

<li>
ExtensionDefinition</li>

<li>
ControlDefinition</li>

<li>
SASLDefinition</li>

<br>&nbsp;</ul>

<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Name of Binding</th>

<th>Description of Binding</th>
</tr>

<tr>
<td><a href="#ATTRSCHEMA">AttributeDefinition</a></td>

<td>Root of the attribute definition tree: a flat namespace with attributes
identified by their name or OID.</td>
</tr>

<tr NOSAVE>
<td><a href="#CLASSSCHEMA">ClassDefinition</a></td>

<td NOSAVE>Root of the "objectclass" definition tree: a flat namespace
with object classes identified by their name or OID.</td>
</tr>

<tr NOSAVE>
<td><a href="#SYNTAXSCHEMA">SyntaxDefinition</a></td>

<td NOSAVE>Root of the syntax definition tree: a flat namespace with syntaxes
identified by their OID.</td>
</tr>

<tr NOSAVE>
<td NOSAVE><a href="#MATCHSCHEMA">MatchingRule</a></td>

<td>Root of matching rule tree: a flat namespace with matching rules identified
by their name or OID.</td>
</tr>

<tr>
<td><a href="#EXTSCHEMA">ExtensionDefinition</a></td>

<td>Root of the extensions tree: a flat namespace with extensions identified
by their OID.</td>
</tr>

<tr>
<td><a href="#CTLSCHEMA">ControlDefinition</a></td>

<td>Root of the controls tree: a flat namespace with controls identified
by their OID.</td>
</tr>

<tr>
<td><a href="#SASLSCHEMA">SASLMechanism</a></td>

<td>Root of the SASL tree: a flat namespace with SASL authentication mechanisms
identified by their string name.</td>
</tr>
</table></center>

<p>Any or all of these bindings may be absent if the underlying directory
does not publish such schema information, or the service provider does
not support retrieving them. If these names are present in the root schema
context, however, they must have the binding specified in the above table.
<p>The attribute names and values of these entries' attributes are case-insensitive.
<br><a NAME="ATTRSCHEMA"></a>
<h3>
8.2 Attribute Definitions</h3>
The name "AttributeDefinition" is bound to a context containing
<tt>DirContext</tt>
objects representing attribute definitions in the schema. For example,
if a directory supports a "commonName" attribute, the "AttributeDefinition"
context would have a binding with name "commonName" that is bound to a
<tt>DirContext</tt>
object.
<p>Each object in the "AttributeDefinition" context has the following mandatory
and optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr>
<td>NUMERICOID (<font color="#CC0000">mandatory</font>)</td>

<td>unique identifier (OID)</td>
</tr>

<tr>
<td>NAME</td>

<td>attribute's name</td>
</tr>

<tr>
<td>DESC</td>

<td>attribute's description</td>
</tr>

<tr>
<td>OBSOLETE</td>

<td>"true" if obsolete, "false" or absent otherwise</td>
</tr>

<tr>
<td>SUP</td>

<td>name of superior attribute type from which this attribute's type is
derived</td>
</tr>

<tr NOSAVE>
<td>EQUALITY</td>

<td NOSAVE>name or OID of matching rule if equality matching allowed, absent
otherwise</td>
</tr>

<tr>
<td>ORDERING</td>

<td>name or OID of matching rule if ordering matching allowed, absent otherwise</td>
</tr>

<tr>
<td>SUBSTRING</td>

<td>name or OID of matching rule if substring matching allowed, absent
otherwise</td>
</tr>

<tr>
<td>SYNTAX</td>

<td>numeric OID of syntax of values of this type</td>
</tr>

<tr>
<td>SINGLE-VALUE</td>

<td>"true" if attribute not multi-valued, "false" or absent otherwise.</td>
</tr>

<tr>
<td>COLLECTIVE</td>

<td>"true" if attribute is collective, "false" or absent otherwise.</td>
</tr>

<tr>
<td>NO-USER-MODIFICATION</td>

<td>"true" if not user-modifiable, "false" or absent otherwise.</td>
</tr>

<tr>
<td>USAGE</td>

<td>description of attribute usage</td>
</tr>
</table></center>

<p>These attributes have a 1-to-1 correspondence with the names defined
in
<a href="http://www.ietf.org/rfc/rfc2252.txt">RFC-2252</a> for "AttributeTypeDescription."
All the attribute values are represented by the <tt>java.lang.String</tt>
class.
<p>You can, for example, obtain the object representing the "cn" attribute
using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext cnSchema = schema.lookup("AttributeDefinition/cn");</pre>
</blockquote>
If you then get the attributes of the "cnSchema" <tt>DirContext</tt> object,
you would see:
<blockquote>
<pre>NUMERICOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.5.4.3
NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cn
SYNTAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.4.1.1466.115.121.1.15
DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Standard Attribute, alias for commonName</pre>
</blockquote>
An equivalent way of getting "cnSchema" is if you already have a "cn" attribute.
The following code illustrates this alternative:
<blockquote>
<pre>Attributes attrs = ctx.getAttributes("cn=John", new String[]{"cn"});
Attribute cnAttr = attrs.get("cn");
DirContext cnSchema = cnAttr.getAttributeDefinition();</pre>
</blockquote>
<a NAME="CLASSSCHEMA"></a>
<h3>
8.3 Object Class Definitions</h3>
The name "ClassDefinition" is bound to a context containing
<tt>DirContext</tt>
objects representing object class definitions in the schema. For example,
if a directory supports a "country" object class, the "ClassDefinition"
context would have a binding with name "country" that is bound to a <tt>DirContext</tt>
object.
<p>Each object in the "ClassDefinition" context has the following mandatory
and optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<caption>&nbsp;</caption>

<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr>
<td>NUMERICOID (<font color="#CC0000">mandatory</font>)</td>

<td>unique identifier (OID)</td>
</tr>

<tr>
<td>NAME</td>

<td>object class's name</td>
</tr>

<tr>
<td>DESC</td>

<td>object class's description</td>
</tr>

<tr>
<td>OBSOLETE</td>

<td>"true" if obsolete, "false" or absent otherwise</td>
</tr>

<tr>
<td>SUP</td>

<td>name of superior object class from which this object class is derived</td>
</tr>

<tr NOSAVE>
<td NOSAVE>ABSTRACT</td>

<td>"true" if object class is abstract, "false" or absent otherwise</td>
</tr>

<tr>
<td>STRUCTURAL</td>

<td>"true" if object class is structural, "false" or absent otherwise</td>
</tr>

<tr>
<td>AUXILIARY</td>

<td>"true" if object class is auxiliary, "false" or absent otherwise</td>
</tr>

<tr>
<td>MUST</td>

<td>a list of type names of attributes that must be present</td>
</tr>

<tr>
<td>MAY</td>

<td>a list of type names of attributes that may be present</td>
</tr>
</table></center>

<p>These attributes have a 1-to-1 correspondence with the names defined
in <a href="http://www.ietf.org/rfc/rfc2252.txt">RFC-2252</a> for "ObjectClassDescription."
All the attribute values are represented by the <tt>java.lang.String</tt>
class.
<p>You can, for example, obtain the object representing the "country" object
class using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext countrySchema = schema.lookup("ClassDefinition/country");</pre>
</blockquote>
If you then get the attributes of the "countrySchema" <tt>DirContext</tt>
object, you would see:
<blockquote>
<pre>NUMERICOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.5.6.2
NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; country
MAY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aci, searchguide, description
MUST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectclass, c
DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Standard ObjectClass
SUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top</pre>
</blockquote>
An equivalent way of getting "countrySchema" is if you already have a "country"
object. The following code illustrates this alternative:
<blockquote>
<pre>// Read object from directory
DirContext countryObj = (DirContext)ctx.lookup("c=us", new String[]{"country"});

// Get all of object's object class definitions
DirContext objClasses = countryAttr.getSchemaClassDefinition();

// Pick out "country" object class in particular
DirContext countryClass = (DirContext)objClasses.lookup("country");</pre>
</blockquote>
<i>Note:</i> JNDI 1.1's specification of
<tt>getSchemaClassDefinition()</tt>
implies that the service provider should return any one of an object's
object class definitions. This specification is inadequate because an object
usually has multiple object classes and the application might require knowledge
about any of those object classes depending on what it is doing. The proposal
as illustrated by the example above is to return a context containing all
of the object class definitions.
<br><a NAME="SYNTAXSCHEMA"></a>
<h3>
8.4 Syntax Definitions</h3>
The name "SyntaxDefinition" is bound to a context containing
<tt>DirContext</tt>
objects representing syntax definitions in the schema. For example, if
a directory supports the "1.3.6.1.4.1.1466.115.121.1.15" syntax (Directory
String) syntax, the "SyntaxDefinition" context would have a binding with
name "1.3.6.1.4.1.1466.115.121.1.15" that is bound to a <tt>DirContext</tt>
object.
<p>Each object in "SyntaxDefinition" context has the following mandatory
and optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr NOSAVE>
<td NOSAVE>NUMERICOID (<font color="#CC0000">mandatory</font>)</td>

<td>unique identifier (OID)</td>
</tr>

<tr>
<td>DESC</td>

<td>syntax's description</td>
</tr>
</table></center>

<p>These attributes have a 1-to-1 correspondence with the names defined
in <a href="http://www.ietf.org/rfc/rfc2252.txt">RFC-2252</a> for "SyntaxDescription."
All the attribute values are represented by the <tt>java.lang.String</tt>
class.
<p>You can, for example, obtain the object representing the "1.3.6.1.4.1.1466.115.121.1.15"
syntax using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext dirStringSchema =&nbsp;
&nbsp;&nbsp;&nbsp; schema.lookup("SyntaxDefinition/1.3.6.1.4.1.1466.115.121.1.15");</pre>
</blockquote>
If you then get the attributes of the "dirStringSchema" <tt>DirContext</tt>
object, you would see:
<blockquote>
<pre>NUMERICOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.4.1.1466.115.121.1.15
DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Directory String</pre>
</blockquote>
An equivalent way of getting "dirStringSchema" is if you already have an
attribute that has that syntax (such as, the "country" attribute). The
following code illustrates this alternative:
<blockquote>
<pre>Attributes attrs = ctx.getAttributes("c=us", new String[]{"country"});
Attribute countryAttr = attrs.get("country");
DirContext dirStringSchema = countryAttr.getSyntaxAttributeDefinition();</pre>
</blockquote>
<a NAME="MATCHSCHEMA"></a>
<h3>
8.5 Matching Rules</h3>
The name "MatchingRule" is bound to a context containing <tt>DirContext</tt>
objects representing matching rules in the schema. A "matching rule" uniquely
identifies the algorithm to use when comparing attribute values. For example,
a directory might support a matching rule that is based on how a string
sounds and define it as the "soundAlikeMatch" matching rule. Then, the
"MatchingRule" context would have a binding with name "soundAlikeMatch"
that is bound to a
<tt>DirContext</tt> object.
<p>When a matching rule is an extensible matching rule, it must also contain
an "APPLIES" attribute listing the attributes to which this extensible
matching rule can be applied.
<p>Each object in "MatchingRule" context has the following mandatory and
optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr>
<td>NUMERICOID (<font color="#CC0000">mandatory</font>)</td>

<td>unique identifier (OID)</td>
</tr>

<tr>
<td>NAME</td>

<td>name of matching rule</td>
</tr>

<tr NOSAVE>
<td>DESC</td>

<td NOSAVE>matching rule's description</td>
</tr>

<tr>
<td>OBSOLETE</td>

<td>"true" if obsolete, "false" or absent otherwise</td>
</tr>

<tr>
<td>SYNTAX</td>

<td>numeric oid of syntax to which this rule applies</td>
</tr>

<tr>
<td>APPLIES</td>

<td>a list type names of attributes to which this extensible matching rule
applies</td>
</tr>
</table></center>

<p>These attributes have a 1-to-1 correspondence with the names defined
in <a href="http://www.ietf.org/rfc/rfc2252.txt">RFC-2252</a> for "MatchingRuleDescription"
and "MatchingRuleUseDescription." All the attribute values are represented
by the <tt>java.lang.String</tt> class.
<p>You can, for example, obtain the object representing the "soundAlikeMatch"
syntax using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext soundMatchSchema =&nbsp;
&nbsp;&nbsp;&nbsp; schema.lookup("MatchingRule/soundAlikeMatch");</pre>
</blockquote>
If you then get the attributes of the "soundMatchSchema" <tt>DirContext</tt>
object, you would see:
<blockquote>
<pre>NUMERICOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.2.3.4.5
NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soundAlikeMatch
SYNTAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.4.1.1466.115.121.1.15 (for directory string)
APPLIES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.5.4.41, 2.5.4.15
DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Home-grown Phonetic match</pre>
</blockquote>
<a NAME="EXTSCHEMA"></a>
<h3>
8.6 Extension Definitions</h3>
The name "ExtensionDefinition" is bound to a context containing
<tt>DirContext</tt>
objects representing extensions supported by the server. For example, a
directory might support the 
<a href=
"http://www.ietf.org/internet-drafts/draft-ietf-ldapext-ldapv3-tls-06.txt">
"Start TLS" extension</a> ("1.3.6.1.4.1.1466.20037"). Then, the
"ExtensionDefinition"
context would have a binding with name "1.3.6.1.4.1.1466.20037" that is
bound to a <tt>DirContext</tt> object.
<p>Each object in "ExtensionDefinition" context has the following mandatory
and optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr NOSAVE>
<td NOSAVE>NUMERICOID (<font color="#CC0000">mandatory</font>)</td>

<td>unique identifier (OID)</td>
</tr>

<tr>
<td>DESC</td>

<td>extension's description</td>
</tr>
</table></center>

<p>All the attribute values are represented by the <tt>java.lang.String</tt>
class.
<p>You can, for example, obtain the object representing the Start TLS extension
("1.3.6.1.4.1.1466.20037") using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext startTLSSchema =&nbsp;
&nbsp;&nbsp;&nbsp; schema.lookup("ExtensionDefinition/1.3.6.1.4.1.1466.20037");</pre>
</blockquote>
If you then get the attributes of the "startTLSSchema" <tt>DirContext</tt>
object, you would see:
<blockquote>
<pre>NUMERICOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3.6.1.4.1.1466.20037
DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Start TLS (see draft-ietf-ldapext-ldapv3-tls-06.txt)</pre>
</blockquote>
<a NAME="CTLSCHEMA"></a>
<h3>
8.7 Control Definitions</h3>
The name "ControlDefinition" is bound to a context containing
<tt>DirContext</tt>
objects representing controls supported by the server. For example, a directory
might support the control for asking the server to sort the search results
it returns.
<p>Each object in "ControlDefinition" context has the following mandatory
and optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr NOSAVE>
<td NOSAVE>NUMERICOID (<font color="#CC0000">mandatory</font>)</td>

<td>unique identifier (string)</td>
</tr>

<tr>
<td>DESC</td>

<td>control's description</td>
</tr>
</table></center>

<p>All the attribute values are represented by the <tt>java.lang.String</tt>
class.
<p>You can, for example, obtain the object representing the <a href="http://www.ietf.org/rfc/rfc2891.txt">server-side
sorting control</a> ("1.2.840.113556.1.4.473") using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext svrSortSchema =&nbsp;
&nbsp;&nbsp;&nbsp; schema.lookup("ControlDefinition/1.2.840.113556.1.4.473");</pre>
</blockquote>
If you then get the attributes of the "svrSortSchema" <tt>DirContext</tt>
object, you would see:
<blockquote>
<pre>NUMERICOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.2.840.113556.1.4.473
DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; server-side sorting of search results</pre>
</blockquote>
<a NAME="SASLSCHEMA"></a>
<h3>
8.8 SASL Mechanisms</h3>
The name "SASLMechanism" is bound to a context containing
<tt>DirContext</tt>
objects representing SASL authentication mechanisms supported by the server.
For example, a directory might support the EXTERNAL SASL mechanism (<a href="http://www.ietf.org/rfc/rfc2222.txt">RFC-2222</a>)
which requests that the server make use of security credentials exchanged
by a lower layer.
<p>Each object in "SASLMechanism" context has the following mandatory and
optional attributes:
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="70%" NOSAVE >
<tr>
<th>Attribute Identifier</th>

<th>Attribute Value Description</th>
</tr>

<tr NOSAVE>
<td NOSAVE>NAME (<font color="#CC0000">mandatory</font>)</td>

<td>SASL mechanism's name</td>
</tr>

<tr>
<td>DESC</td>

<td>SASL mechanism's description</td>
</tr>
</table></center>

<p>All the attribute values are represented by the <tt>java.lang.String</tt>
class.
<p>You can, for example, obtain the object representing the EXTERNAL SASL
mechanism using the following code:
<blockquote>
<pre>DirContext schema = ctx.getSchema(""); // get schema tree
DirContext saslExternalSchema =&nbsp;
&nbsp;&nbsp;&nbsp; schema.lookup("SASLMechanism/EXTERNAL");</pre>
</blockquote>
If you then get the attributes of the "saslExternalSchema" <tt>DirContext</tt>
object, you would see:
<blockquote><tt>NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL</tt>
<br><tt>DESC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL SASL mechanism (RFC-2222)</tt></blockquote>

<hr><a NAME="EXCEPT"></a>
<h2>
9. Exceptions</h2>
When building an LDAP provider, you need to translate LDAP error codes
(see
<a href="http://www.ietf.org/rfc/rfc2251.txt">RFC-2251</a>) into
JNDI exceptions. You should use the following table when performing the
translation. Furthermore, you should encode as much information as possible
about the error into the exception's detailed message, "root cause" exception,
resolved and remaining names. Note that resolved name and resolved object
should correspond to each other's setting.
<br>&nbsp;
<center><table BORDER CELLPADDING=3 WIDTH="100%" NOSAVE >
<tr>
<th>LDAP error code</th>

<th>Exception or Action</th>
</tr>

<tr>
<td>success (0)</td>

<td>Report success.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>operationsError (1)</td>

<td><tt>NamingException</tt></td>
</tr>

<tr>
<td>protocolError (2)</td>

<td><tt>CommunicationException</tt></td>
</tr>

<tr NOSAVE>
<td NOSAVE>timeLimitExceeded (3)</td>

<td NOSAVE><tt>TimeLimitExceededException</tt></td>
</tr>

<tr>
<td>sizeLimitExceeded (4)</td>

<td><tt>SizeLimitExceededException</tt></td>
</tr>

<tr NOSAVE>
<td>compareFalse (5)</td>

<td NOSAVE>Used by <tt>DirContext.search()</tt> and does not generate an
exception.</td>
</tr>

<tr NOSAVE>
<td>compareTrue (6)</td>

<td NOSAVE>Used by <tt>DirContext.search()</tt> and does not generate an
exception.</td>
</tr>

<tr>
<td>authMethodNotSupported (7)</td>

<td><tt>AuthenticationNotSupportedException</tt></td>
</tr>

<tr>
<td>strongAuthRequired (8)</td>

<td><tt>AuthenticationNotSupportedException</tt></td>
</tr>

<tr>
<td>partialResults (9)</td>

<td>If <tt>java.naming.referral</tt> is set to <tt>ignore</tt>, or contents
of error does not contain a referral, throw
<tt>PartialResultException</tt>.
Otherwise, use the contents to build a referral.</td>
</tr>

<tr>
<td>referral (10)</td>

<td>If <tt>java.naming.referral</tt> is set to <tt>ignore</tt> then throw
<tt>PartialResultException</tt>.
If it is set to <tt>throw</tt> then throw
<tt>ReferralException</tt>. If
it is set to <tt>follow</tt> then the provider shall follow the referral.
If the value for <tt>java.naming.ldap.referral.limit</tt> is exceeded while
following the referral then throw <tt>LimitExceededException</tt>.</td>
</tr>

<tr>
<td>adminLimitExceeded (11)</td>

<td><tt>LimitExceededException</tt></td>
</tr>

<tr>
<td>unavailableCriticalExtension (12)</td>

<td><tt>OperationNotSupportedException</tt></td>
</tr>

<tr>
<td>confidentialityRequired (13)</td>

<td><tt>AuthenticationNotSupportedException</tt></td>
</tr>

<tr>
<td>saslBindInProgress (14)</td>

<td>Used internally by LDAP provider during multi-stage SASL authentication.</td>
</tr>

<tr>
<td>noSuchAttribute (16)</td>

<td><tt>NoSuchAttributeException</tt></td>
</tr>

<tr>
<td>undefinedAttributeType (17)</td>

<td><tt>InvalidAttributeIdentifierException</tt></td>
</tr>

<tr>
<td>inappropriateMatching (18)</td>

<td><tt>InvalidSearchFilterException</tt></td>
</tr>

<tr>
<td>constraintViolation (19)</td>

<td><tt>InvalidAttributeValueException</tt></td>
</tr>

<tr>
<td>attributeOrValueExists (20)</td>

<td><tt>AttributeInUseException</tt></td>
</tr>

<tr>
<td>invalidAttributeSyntax (21)</td>

<td><tt>InvalidAttributeValueException</tt></td>
</tr>

<tr>
<td>noSuchObject (32)</td>

<td><tt>NameNotFoundException</tt></td>
</tr>

<tr>
<td>aliasProblem (33)</td>

<td><tt>NamingException</tt></td>
</tr>

<tr>
<td>invalidDNSyntax (34)</td>

<td><tt>InvalidNameException</tt></td>
</tr>

<tr>
<td>isLeaf (35)</td>

<td>Used by provider; usually doesn't generate exception.</td>
</tr>

<tr>
<td>aliasDereferencingProblem (36)</td>

<td><tt>NamingException</tt></td>
</tr>

<tr>
<td>inappropriateAuthentication (48)</td>

<td><tt>AuthenticationNotSupportedException</tt></td>
</tr>

<tr>
<td>invalidCredentials (49)</td>

<td><tt>AuthenticationException</tt></td>
</tr>

<tr>
<td>insufficientAccessRights (50)</td>

<td><tt>NoPermissionException</tt></td>
</tr>

<tr>
<td>busy (51)</td>

<td><tt>ServiceUnavailableException</tt></td>
</tr>

<tr>
<td>unavailable (52)</td>

<td><tt>ServiceUnavailableException</tt></td>
</tr>

<tr>
<td>unwillingToPerform (53)</td>

<td><tt>OperationNotSupportedException</tt></td>
</tr>

<tr>
<td>loopDetect (54)</td>

<td><tt>NamingException</tt></td>
</tr>

<tr>
<td>namingViolation (64)</td>

<td><tt>InvalidNameException</tt></td>
</tr>

<tr>
<td>objectClassViolation (65)</td>

<td><tt>SchemaViolationException</tt></td>
</tr>

<tr>
<td>notAllowedOnNonLeaf (66)</td>

<td><tt>ContextNotEmptyException</tt></td>
</tr>

<tr>
<td>notAllowedOnRDN (67)</td>

<td><tt>SchemaViolationException</tt></td>
</tr>

<tr>
<td>entryAlreadyExists (68)</td>

<td><tt>NameAlreadyBoundException</tt></td>
</tr>

<tr>
<td>objectClassModsProhibited (69)</td>

<td><tt>SchemaViolationException</tt></td>
</tr>

<tr>
<td>affectsMultipleDSAs (71)</td>

<td><tt>NamingException</tt></td>
</tr>

<tr>
<td>other (80)</td>

<td><tt>NamingException</tt></td>
</tr>
</table></center>

<p>
<hr><a NAME="API"></a>
<h2>
10. API Mapping</h2>
The methods of the JNDI API context interfaces are mapped onto LDAP operations
as follows.
<br>&nbsp;
<dt>
<b><tt>EventContext.addNamingListener</tt></b></dt>
<dt>
<b><tt>EventDirContext.addNamingListener</tt></b></dt>

<blockquote>
<dt>
Register a listener for receiving naming events that take place in the
specified subtree of LDAP entries. LDAP servers notify clients of events
by means of LDAP controls attached to LDAP operation responses or by means
of an LDAP unsoliciated notifications.
Such responses are then processed by the LDAP provider and indicated to the
application in the form of <tt>NamingEvent</tt>
or <tt>UnsolicitedNotificationEvent</tt>.
</dt>
</blockquote>

<dt>
<b><tt>Context.addToEnvironment</tt></b></dt>

<blockquote>Update context's environment properties. If multiple contexts
share the same set of environment properties, the provider should take
care to only modify the intended context's environment. Changing an environment
property might require changes to the existing connection the context is
using.</blockquote>

<dl>
<dl>Supplying null for the property value has the same effect as removing
the property.
<p>For all environment properties, the new property is recorded even if
it does not affect the context. See the <a href="#PROP">Environment Properties</a>
section.</dl>
</dl>

<dt>
<b><tt>Context.bind</tt></b></dt>

<br><b><tt>DirContext.bind</tt></b>
<dl>
<dl>Perform an LDAP add operation to create a new entry in the directory.
The
<tt>DirContext.bind</tt> method can accept null as the object to bind
if it is also supplied a non-null set of attributes. Otherwise, if the
method is given insufficient information (i.e., no object or attributes),
no entry can be added. If an object is provided in the arguments, then
it is converted into attributes and stored in the entry along with any
supplied attributes, as described in the <a href="#OBJ">Java Objects</a>
section. The provider should use the <tt>DirectoryManager.getStateToBind</tt>
method to transform the input object into a form that it can store.
<p>If the provider does not support binding any objects in the directory
then it should throw <tt>OperationNotSupportedException</tt>. Otherwise,
if it does support binding objects but does not support the supplied object
then it should throw <tt>IllegalArgumentException</tt>.</dl>
</dl>

<dt>
<b><tt>Context.close</tt></b></dt>

<dl>
<dl>Release resources associated with context. For example, if the connection
being used by this context is not shared with another context, the provider
may abandon any outstanding requests and close the network connection to
the server. Precisely which resources are released is implementation-dependent.</dl>

<dt>
<b><tt>Context.composeName</tt></b></dt>
</dl>

<dl>
<dl>
If the parent context is from the same LDAP namespace,
then concatenate the names according to the LDAP name syntax described in
<tt>Context.getNameParser()</tt>.
Otherwise, concatenate the names as composite names.
</dl>
</dl>

<dt>
<b><tt>Context.createSubcontext</tt></b></dt>

<br><b><tt>DirContext.createSubcontext</tt></b>
<dl>
<dl>Perform an LDAP add operation to create the named entry and its associated
attributes. If no attributes are supplied then the objectClass attribute
is generated with the values <tt>top</tt> and <tt>javaContainer</tt>
(<tt>javaContainer</tt> is a
structural class that is necessary to avoid a schema violation error).</dl>
</dl>

<dt>
<b><tt>Context.destroySubcontext</tt></b></dt>

<dl>
<dl>Perform an LDAP delete operation to remove the named entry and its
associated attributes. The named entry must be a leaf entry; subtrees are
not removed. If the leaf entry does not exist (but its parent exists),
the operation still succeeds.</dl>
</dl>

<dt>
<b><tt>LdapContext.extendedOperation</tt></b></dt>

<blockquote>
<dt>
Perform an LDAP extended operation.</dt>
</blockquote>

<dt>
<b><tt>DirContext.getAttributes</tt></b></dt>

<dl>
<dl>Perform an LDAP base-object search operation to retrieve the LDAP entry's
attributes. Use "(objectclass=*)" as the filter.
<p>If the list of requested attributes is null or contains the special
attribute identifier '*' then all the user attributes at the LDAP entry
are returned. If <i>operational</i> attributes are required then those
attribute identifiers must be present in the list of requested attributes.</dl>
</dl>

<dt>
<b><tt>LdapContext.getConnectControls</tt></b></dt>

<dl>
<dl>
<dt>
Retrieve the connection request controls in effect for LDAP bind operations
invoked on this context.</dt>
</dl>
</dl>


<dt>
<b><tt>Context.getEnvironment</tt></b></dt>

<dl>
<dl>Return the environment properties recorded at the context.</dl>

<p>
<dt>
<b><tt>Context.getNameInNamespace</tt></b></dt>
<p>
<dl>Return the LDAP distinguished name of the context.</dl>

<p>
<dt>
<b><tt>Context.getNameParser</tt></b></dt>
<p>
<dl>Return a name parser that parses LDAP names according to <a href="http://www.ietf.org/rfc/rfc2253.txt">RFC-2253</a>.</dl>
</dl>

<dt>
<b><tt>LdapContext.getRequestControls</tt></b></dt>

<dl>
<dl>
<dt>
Retrieve the request controls in effect for LDAP operations subsequently
invoked on this context.</dt>
</dl>
</dl>

<dt>
<b><tt>LdapContext.getResponseControls</tt></b></dt>

<dl>
<dl>
<dt>
Retrieve the response controls returned by the last LDAP operation invoked
on this context.</dt>
</dl>
</dl>

<dt>
<b><tt>DirContext.getSchema</tt></b></dt>

<dl>
<dl>See the <a href="#SCHEMA">Schema Section</a>.</dl>
</dl>

<dt>
<b><tt>DirContext.getSchemaClassDefinition</tt></b></dt>

<dl>
<dl>See the <a href="#SCHEMA">Schema Section</a>.</dl>
</dl>

<dt>
<b><tt>Context.list</tt></b></dt>

<dl>
<dl>Perform an LDAP one-level search operation of the named entry using
the filter "(objectclass=*)" to retrieve the names of the entries immediately
below the named entry.
<p>Ask for, at a minimum,
the <tt>javaClassName</tt> attributes so that the class
name of each entry can be determined. If the class name cannot
be determined, return <tt>javax.naming.directory.DirContext</tt> as
the class name.
<p>The names which are returned are either relative to the named context
or they are LDAP URLs.</dl>
</dl>

<dt>
<b><tt>Context.listBindings</tt></b></dt>

<dl>
<dl>Perform an LDAP one-level search operation of the named entry using
the filter "(objectclass=*)" to retrieve the attributes representing objects
(or object references). Request the attributes for reconstructing
the Java object and possibly other attributes as well. 
See <a href="#OBJ">Java Objects</a> on how to reconstruct
the object. If the object cannot be reconstructed according to 
<a href="http://www.ietf.org/rfc/rfc2713.txt">RFC 2713</a>
then return a <tt>DirContext</tt> object representing the LDAP entry. The
provider should use the <tt>DirectoryManager.getObjectInstance</tt> method
to satisfy calls to the <tt>Binding.getObject</tt> method.
<p>The names which are returned are either relative to the named context
or they are LDAP URLs.</dl>
</dl>

<dt>
<b><tt>Context.lookup</tt></b></dt>

<br><b><tt>Context.lookupLink</tt></b>
<dl>
<dl>Perform an LDAP base-object search operation of the named entry using
the filter "(objectclass=*)". Request (possibly all) the attributes for
reconstructing the Java object. See <a href="#OBJ">Java Objects</a> on
how to reconstruct the object. The provider should use the <tt>DirectoryManager.getObjectInstance</tt>
method to satisfy calls to the <tt>Binding.getObject</tt> method.</dl>
</dl>

<dt>
<b><tt>DirContext.modifyAttributes</tt></b></dt>

<dl>
<dl>Perform an LDAP modify operation at the named entry using the supplied
modifications. For the overloaded method that accepts an <tt>Attributes</tt>,
first convert the <tt>Attributes</tt> argument into an ordered list of
modifications by enumerating its contents using <tt>Attributes.getAll()</tt>
and reusing the modification operation argument (<tt>mod_op</tt>).</dl>
</dl>
<b><tt>LdapContext.newInstance</tt></b>
<dl>
<dl>
<dt>
Initialize an new instance of this context with the specified request controls.</dt>
</dl>
</dl>

<dl>
<dt>
<b><tt>Context.rebind</tt></b></dt>

<br><b><tt>DirContext.rebind</tt></b></dl>

<dl>
<dl>This method may involve several different LDAP operations. First get
the existing entry's attributes. If the existing entry does not exist,
this method behaves the same as <tt>bind()</tt>. Otherwise, if no attributes
have been supplied and the object being bound is <tt>DirContext</tt>, invoke
<tt>DirContext.getAttributes()</tt>
and use the result as the attributes argument (<tt>attrs</tt>). If there
are still no attributes, use the original entry's attributes as <tt>attrs</tt>.
Remove the existing entry using the LDAP delete operation. Convert the
object provided in the arguments into attributes (as described in the <a href="#OBJ">Java
Objects</a> section) and store in the entry along with <tt>attrs</tt> using
the LDAP add operation. The provider should use the <tt>DirectoryManager.getStateToBind</tt>
method to transform the input object into a form that it can store.
</dl>
</dl>

<dl>
<dt>
<b><tt>LdapContext.reconnect</tt></b></dt>
<p>
<dl>Reconnect to the LDAP server using the supplied connection request controls
and the current environment properties.
<dl>
<dt>
</dt>
</dl>
</dl>
<p>

<dt>
<b><tt>Context.removeFromEnvironment</tt></b></dt>
</dl>

<blockquote>Remove context's environment properties. If multiple contexts
share the same set of environment properties, the provider should take
care to only modify the intended context's environment. Changing an environment
property might require changes to the existing connection the context is
using.</blockquote>

<dl>
<dl>
<dt>
For all environment properties, the new property is recorded even if it
does not affect the context. Removing a property should cause the context
to assume the property's default.</dt>
</dl>
</dl>

<dl>
<dt>
<b><tt>EventContext.removeNamingListener</tt></b></dt>
</dl>

<blockquote>
<dt>
Deregister a naming event listener so that subsequent events
destined for that listener are not delivered.</dt>
</blockquote>

<dt>
<b><tt>Context.rename</tt></b></dt>

<dl>
<dl>Perform an LDAP modify DN operation to rename the entry. If LDAPv2
is being used then the new name and the old name must share the same immediate
parent name. If the parents are not equal then throw <tt>InvalidNameException</tt>.
<p>Note the effect of the&nbsp; <a href="#deleteRDN">java.naming.ldap.deleteRDN</a>&nbsp;
property on the behavior of this method.</dl>
</dl>

<dt>
<b><tt>DirContext.search</tt></b></dt>

<dl>
<dl>Perform an LDAP search operation according to the specified search
controls.
<p>If the list of requested attributes is null or contains the special
attribute identifier '*' then all the user attributes at the LDAP entry
are returned. If operational attributes are required then those attribute
identifiers must be present in the list of requested attributes.
<p>If objects are requested to be returned, then the Java object-related
attributes (<a href="http://www.ietf.org/rfc/rfc2713.txt">RFC 2713</a>)
are requested in addition to any requested by the API user. If these attributes
are present then they are used to assemble the original objects (see <a href="#OBJ">Java
Objects</a>). If the object cannot be reconstructed according to 
<a href="http://www.ietf.org/rfc/rfc2713.txt">RFC 2713</a>
then return a <tt>DirContext</tt> object representing the LDAP entry. The
provider should use the <tt>DirectoryManager.getObjectInstance</tt> method
to satisfy calls to the <tt>Binding.getObject</tt> method.
<p>The names which are returned are either relative to the named context
or they are LDAP URLs.
<p>The provider may use an LDAP compare operation instead of an LDAP search
when the search filter supplied is suitably constrained:
<br>&nbsp;
<dl>
<li>
The filter must be of the form "<tt>(&lt;attributeID>=&lt;value>)</tt>"</li>

<li>
The scope must be object scope</li>

<li>
Zero attributes must be requested (empty returning-attributes list)</li>
</dl>

<p>In the forms of search that accept a string filter as argument,
the syntax of the filter follows
<a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254</a>
with the exception that Unicode characters are also allowed. The use of
Unicode characters is preferable to the use of encoded UTF-8 octets. The
service provider is responsible for translating the Unicode characters
into their corresponding UTF-8 representation for transmission to the server.
For example, the Greek letter alpha can be specified in the string filter
either as "<tt>\u03B1</tt>" or as "<tt>\\CE\\B1</tt>".
<p>In the form <tt>search(Name, Attributes)</tt> and related methods, the
<tt>Attributes</tt>
argument is converted into a string filter by creating a conjunctive expression
out of its elements. Each attribute value is treated as a literal; therefore
'*' and other special characters defined in <a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254</a> that appear in
the values of an attribute should be escaped according to
the rules in <a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254</a>.
For example, an attribute value of '*' should be encoded as the string
"<tt>\\2a</tt>".
<p>In the form <tt>search(Name, String filterExpr, Object[] filterArgs)</tt>
and its <tt>String</tt> overloaded method, "{<i>num</i>}" expansion is
done in the filter by putting in values from <tt>filterArgs</tt>. Each
"{<i>num</i>}" component may appear in the place of "attr" or "value" in
Section 4 from
<a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254.</a>
<p>The objects in <tt>filterArgs</tt> should be encoded in the following
way:
<br>&nbsp;
<dl>
<li>
byte arrays (<tt>byte[]</tt>) are encoded by encoding each byte as a string
according to <a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254</a>.
For example, the array {0, 1, 10, 100} is encoded as the string "<tt>\\00\\01\\0a\\64</tt>".</li>

<li>
Strings are treated as literals. In other words, '*' and other special
characters defined in <a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254</a>
that appear in the string are escaped according to the rules in <a href="http://www.ietf.org/rfc/rfc2254.txt">RFC-2254</a>.
For example, a string of "*" is encoded as the string "<tt>\\2a</tt>".</li>

<li>
Objects that are neither <tt>String</tt> nor <tt>byte[]</tt> are converted
to their string form using <tt>Object.toString()</tt> and then the rules
for
<tt>String</tt> applied.</li>
</dl>
</dl>
</dl>

<dt>
<b><tt>LdapContext.setRequestControls</tt></b></dt>

<dl>
<dl>
<dt>
Set the request controls for LDAP operations subsequently invoked on this
context.</dt>
</dl>
</dl>

<dt>
<b><tt>EventContext.targetMustExist</tt></b></dt>

<dl>
<dl>
<dt>
Determine whether a listener can register interest in an LDAP entry that
doesn't exist.</dt>
</dl>
</dl>

<dt>
<b><tt>Context.unbind</tt></b></dt>

<dl>
<dl>Perform an LDAP delete operation to remove the named entry. The named
entry must be a leaf entry; subtrees are not removed. If the leaf entry
does not exist (but its parents exist), the operation still succeeds.</dl>
</dl>

<hr><a NAME="FED"></a>
<h2>
11. Federation</h2>
The LDAP service provider should support federation using strong separation
and either or both of junctions or implicit next naming system pointer.
<p>
<hr>
<br><a NAME="SASL"></a>
<h2>
12. SASL</h2>
The provider supports SASL mechanisms by means of the <a href="http://www.ietf.org/internet-drafts/draft-weltman-java-sasl-03.txt">Java SASL API</a>. 
This allows SASL mechanism drivers from different vendors to be used
with the LDAP provider, and also allows a SASL mechanism driver to be used 
with different LDAP providers and even non-LDAP protocol libraries.
<p>
The Java SASL API depends on the 
<a href="http://java.sun.com/security/jaas/">Java 
Authentication and Authorization Service</a> (JAAS), which provides callback
support for SASL mechanisms that need to obtain or supply user/application
information directly.
<h3>
12.1 SASL Configuration</h3>

To specify that SASL authentication be used, 
you specify the official IANA-registered names of the SASL mechanisms
in the 
<a href=#authentication><tt>java.naming.security.authentication</tt></a>
property.
<p>When an LDAP client connects to an LDAP server, it supplies to the server
the authentication identity of the entity being authenticated. This is
known as the <i>authentication ID</i>.
Some SASL mechanisms, like CRAM-MD5 and DIGEST-MD5, require the use
of a password.
By default, the provider supplies the value of
<a href=#principal><tt>java.naming.security.principal</tt></a> property as 
the authentication ID to any SASL mechanism that requires the authentication ID,
and supplies the value of the 
<a href=#credentials><tt>java.naming.security.credentials</tt></a> 
property as the password.
To override these defaults, use the 
<a href=#callback><tt>java.naming.security.sasl.callback</tt></a>
property.

<p>SASL mechanisms support the notion of authorization identity or <i>authorization
ID</i>, which is the entity to which the server should grant access if the
authentication succeeds.&nbsp;
By default, the value of the 
<a href=#principal><tt>java.naming.security.principal</tt></a>
property is used as the authorization ID.
If the 
<a href=#authorizationId><tt>java.naming.security.sasl.authorizationId</tt></a>
property has been set, then its value is used as the authorization ID instead.

<p>See <a href="#SASLPROPS">SASL properties</a> for a description of the
properties used by an LDAP service provider for supporting SASL.
<p>
In addition to these properties, there might be properties required 
for specific SASL mechanisms.
For example, a SASL mechanism might require a key length for encryption.
Properties such as these are passed to
the SASL mechanism via the environment properties.
See the
<a href=
"../../api/javax/naming/InitialContext.html#ENVIRONMENT">JNDI
documentation</a> for how to set environment properties.
<p>For example, if the application needs to specify the maximum encryption
key length to a SASL mechanism, it can do so by using a call such as:
<p>&nbsp;&nbsp;&nbsp;&nbsp; <tt>env.put("javax.security.sasl.encryption.maximum",
"40");</tt>
<p>before passing <tt>env</tt> to the initial context constructor.
See
<a href="http://www.ietf.org/internet-drafts/draft-weltman-java-sasl-03.txt">draft-weltman-java-sasl-03</a></td>
for details about these properties.
<h3>
12.2 SASL Mechanism Drivers</h3>
The 
<a href="http://www.ietf.org/internet-drafts/draft-weltman-java-sasl-03.txt">Java SASL API</a> provides a framework for dynamically plugging in SASL mechanism
drivers. The LDAP provider might provide a few default drivers.
An application can make additional drivers available to the provider by 
listing the names of the packages, separated by "<tt>|</tt>" (vertical bar),
in the <a href=#pkgs><tt>javax.security.sasl.client.pkgs</tt></a> property.
It must then add the drivers' classes to the application's classpath.
See the
<a href="http://www.ietf.org/internet-drafts/draft-weltman-java-sasl-03.txt">Java SASL API</a> for details.
<p>
<hr><a NAME="CTL"></a>
<h2>
13. Extensions and Controls</h2>
The provider supports LDAP extensions and controls using the <tt>javax.naming.ldap</tt>
package. In addition, the provider supports LDAP unsolicited notifications
(which are transmitted in LDAP extended operation responses) using the
services of the <tt>javax.naming.event</tt> package.
<p>Several LDAP extensions and controls are defined by the IETF <a href="http://www.ietf.org/html.charters/ldapext-charter.html">LDAPEXT</a>
working group.
<p>
<hr><a NAME="EVENT"></a>
<h2>
14. Event Notification</h2>
The provider supports event notification using the <tt>javax.naming.event</tt>
package.
<p>A JNDI application can register for events that occur in the directory,
such as the addition or removal of an entry, or the modification of an
entry. Applications can also register for unsolicited notifications.
<p>
<hr>
<br><a NAME="SSL"></a>
<h2>
15. SSL</h2>
The provider supports SSL according to the <a href="http://java.sun.com/security/ssl/API_users_guide.html">SSL
interface specification</a>. SSL is activated by setting the 
<a href=#protocol><tt>java.naming.security.protocol</tt></a>
environment property as follows:
<blockquote><tt>env.put(Context.SECURITY_PROTOCOL, "ssl");</tt></blockquote>
and by selecting the hostname and port number of an LDAP server that supports
SSL. Once an SSL connection has been established subsequent LDAP protocol
exchanges take place over that secure connection.
<p>If, in addition, LDAP authentication is also required then the 
<a href=#authentication><tt>java.naming.security.authentication</tt></a>,
<a href=#principal><tt>java.naming.security.principal</tt></a>,
and <a href=#credentials><tt>java.naming.security.credentials</tt></a> environment properties should
be set, as appropriate. If LDAP authentication is required and the SSL
credentials should be reused for LDAP authentication then set the 
<a href=#authentication><tt>java.naming.security.authentication</tt></a>
environment property to select the SASL EXTERNAL mechanism, as follows:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>env.put(Context.SECURITY_AUTHENTICATION,
"EXTERNAL");</tt>
<br>&nbsp;
<p>
<hr SIZE=3 NOSHADE WIDTH="100%">
<br><i>Copyright &copy; 1999 Sun Microsystems, Inc., All Rights Reserved.</i>
</body>
</html>
